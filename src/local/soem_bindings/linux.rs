/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _PTHREAD_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const EC_NOFRAME: i32 = -1;
pub const EC_OTHERFRAME: i32 = -2;
pub const EC_ERROR: i32 = -3;
pub const EC_SLAVECOUNTEXCEEDED: i32 = -4;
pub const EC_TIMEOUT: i32 = -5;
pub const EC_MAXECATFRAME: u32 = 1518;
pub const EC_MAXLRWDATA: u32 = 1486;
pub const EC_FIRSTDCDATAGRAM: u32 = 20;
pub const EC_BUFSIZE: u32 = 1518;
pub const EC_ECATTYPE: u32 = 4096;
pub const EC_MAXBUF: u32 = 16;
pub const EC_TIMEOUTRET: u32 = 2000;
pub const EC_TIMEOUTRET3: u32 = 6000;
pub const EC_TIMEOUTSAFE: u32 = 20000;
pub const EC_TIMEOUTEEP: u32 = 20000;
pub const EC_TIMEOUTTXM: u32 = 20000;
pub const EC_TIMEOUTRXM: u32 = 700000;
pub const EC_TIMEOUTSTATE: u32 = 2000000;
pub const EC_MAXEEPBITMAP: u32 = 128;
pub const EC_MAXEEPBUF: u32 = 4096;
pub const EC_DEFAULTRETRIES: u32 = 3;
pub const EC_LOGGROUPOFFSET: u32 = 16;
pub const EC_DATAGRAMFOLLOWS: u32 = 32768;
pub const EC_ESTAT_R64: u32 = 64;
pub const EC_ESTAT_BUSY: u32 = 32768;
pub const EC_ESTAT_EMASK: u32 = 30720;
pub const EC_ESTAT_NACK: u32 = 8192;
pub const ECT_SII_START: u32 = 64;
pub const ECT_SDO_SMCOMMTYPE: u32 = 7168;
pub const ECT_SDO_PDOASSIGN: u32 = 7184;
pub const ECT_SDO_RXPDOASSIGN: u32 = 7186;
pub const ECT_SDO_TXPDOASSIGN: u32 = 7187;
pub const ETH_P_ECAT: u32 = 34980;
pub const EC_MAXELIST: u32 = 64;
pub const EC_MAXNAME: u32 = 40;
pub const EC_MAXSLAVE: u32 = 200;
pub const EC_MAXGROUP: u32 = 2;
pub const EC_MAXIOSEGMENTS: u32 = 64;
pub const EC_MAXMBX: u32 = 1486;
pub const EC_MAXEEPDO: u32 = 512;
pub const EC_MAXSM: u32 = 8;
pub const EC_MAXFMMU: u32 = 4;
pub const EC_MAXLEN_ADAPTERNAME: u32 = 128;
pub const EC_MAX_MAPT: u32 = 1;
pub const ECT_MBXPROT_AOE: u32 = 1;
pub const ECT_MBXPROT_EOE: u32 = 2;
pub const ECT_MBXPROT_COE: u32 = 4;
pub const ECT_MBXPROT_FOE: u32 = 8;
pub const ECT_MBXPROT_SOE: u32 = 16;
pub const ECT_MBXPROT_VOE: u32 = 32;
pub const ECT_COEDET_SDO: u32 = 1;
pub const ECT_COEDET_SDOINFO: u32 = 2;
pub const ECT_COEDET_PDOASSIGN: u32 = 4;
pub const ECT_COEDET_PDOCONFIG: u32 = 8;
pub const ECT_COEDET_UPLOAD: u32 = 16;
pub const ECT_COEDET_SDOCA: u32 = 32;
pub const EC_SMENABLEMASK: u32 = 4294901759;
pub const EC_MAXODLIST: u32 = 1024;
pub const EC_MAXOELIST: u32 = 256;
pub const EC_SOE_DATASTATE_B: u32 = 1;
pub const EC_SOE_NAME_B: u32 = 2;
pub const EC_SOE_ATTRIBUTE_B: u32 = 4;
pub const EC_SOE_UNIT_B: u32 = 8;
pub const EC_SOE_MIN_B: u32 = 16;
pub const EC_SOE_MAX_B: u32 = 32;
pub const EC_SOE_VALUE_B: u32 = 64;
pub const EC_SOE_DEFAULT_B: u32 = 128;
pub const EC_SOE_MAXNAME: u32 = 60;
pub const EC_SOE_MAXMAPPING: u32 = 64;
pub const EC_IDN_MDTCONFIG: u32 = 24;
pub const EC_IDN_ATCONFIG: u32 = 16;
pub const EC_SOE_LENGTH_1: u32 = 0;
pub const EC_SOE_LENGTH_2: u32 = 1;
pub const EC_SOE_LENGTH_4: u32 = 2;
pub const EC_SOE_LENGTH_8: u32 = 3;
pub const EC_SOE_TYPE_BINARY: u32 = 0;
pub const EC_SOE_TYPE_UINT: u32 = 1;
pub const EC_SOE_TYPE_INT: u32 = 2;
pub const EC_SOE_TYPE_HEX: u32 = 3;
pub const EC_SOE_TYPE_STRING: u32 = 4;
pub const EC_SOE_TYPE_IDN: u32 = 5;
pub const EC_SOE_TYPE_FLOAT: u32 = 6;
pub const EC_SOE_TYPE_PARAMETER: u32 = 7;
pub const EOE_DNS_NAME_LENGTH: u32 = 32;
pub const EOE_ETHADDR_LENGTH: u32 = 6;
pub const EOE_HDR_FRAME_TYPE_OFFSET: u32 = 0;
pub const EOE_HDR_FRAME_TYPE: u32 = 15;
pub const EOE_HDR_FRAME_PORT_OFFSET: u32 = 4;
pub const EOE_HDR_FRAME_PORT: u32 = 240;
pub const EOE_HDR_LAST_FRAGMENT_OFFSET: u32 = 8;
pub const EOE_HDR_LAST_FRAGMENT: u32 = 256;
pub const EOE_HDR_TIME_APPEND_OFFSET: u32 = 9;
pub const EOE_HDR_TIME_APPEND: u32 = 512;
pub const EOE_HDR_TIME_REQUEST_OFFSET: u32 = 10;
pub const EOE_HDR_TIME_REQUEST: u32 = 1024;
pub const EOE_HDR_FRAG_NO_OFFSET: u32 = 0;
pub const EOE_HDR_FRAG_NO: u32 = 63;
pub const EOE_HDR_FRAME_OFFSET_OFFSET: u32 = 6;
pub const EOE_HDR_FRAME_OFFSET: u32 = 4032;
pub const EOE_HDR_FRAME_NO_OFFSET: u32 = 12;
pub const EOE_HDR_FRAME_NO: u32 = 61440;
pub const EOE_PARAM_OFFSET: u32 = 4;
pub const EOE_PARAM_MAC_INCLUDE: u32 = 1;
pub const EOE_PARAM_IP_INCLUDE: u32 = 2;
pub const EOE_PARAM_SUBNET_IP_INCLUDE: u32 = 4;
pub const EOE_PARAM_DEFAULT_GATEWAY_INCLUDE: u32 = 8;
pub const EOE_PARAM_DNS_IP_INCLUDE: u32 = 16;
pub const EOE_PARAM_DNS_NAME_INCLUDE: u32 = 32;
pub const EOE_FRAG_DATA: u32 = 0;
pub const EOE_INIT_RESP_TIMESTAMP: u32 = 1;
pub const EOE_INIT_REQ: u32 = 2;
pub const EOE_INIT_RESP: u32 = 3;
pub const EOE_SET_ADDR_FILTER_REQ: u32 = 4;
pub const EOE_SET_ADDR_FILTER_RESP: u32 = 5;
pub const EOE_GET_IP_PARAM_REQ: u32 = 6;
pub const EOE_GET_IP_PARAM_RESP: u32 = 7;
pub const EOE_GET_ADDR_FILTER_REQ: u32 = 8;
pub const EOE_GET_ADDR_FILTER_RESP: u32 = 9;
pub const EOE_RESULT_SUCCESS: u32 = 0;
pub const EOE_RESULT_UNSPECIFIED_ERROR: u32 = 1;
pub const EOE_RESULT_UNSUPPORTED_FRAME_TYPE: u32 = 2;
pub const EOE_RESULT_NO_IP_SUPPORT: u32 = 513;
pub const EOE_RESULT_NO_DHCP_SUPPORT: u32 = 514;
pub const EOE_RESULT_NO_FILTER_SUPPORT: u32 = 1025;
pub const EC_NODEOFFSET: u32 = 4096;
pub const EC_TEMPNODE: u32 = 65535;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sched_param"][::std::mem::size_of::<sched_param>() - 4usize];
    ["Alignment of sched_param"][::std::mem::align_of::<sched_param>() - 4usize];
    ["Offset of field: sched_param::sched_priority"]
        [::std::mem::offset_of!(sched_param, sched_priority) - 0usize];
};
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cpu_set_t"][::std::mem::size_of::<cpu_set_t>() - 128usize];
    ["Alignment of cpu_set_t"][::std::mem::align_of::<cpu_set_t>() - 8usize];
    ["Offset of field: cpu_set_t::__bits"][::std::mem::offset_of!(cpu_set_t, __bits) - 0usize];
};
unsafe extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
unsafe extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
unsafe extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type clock_t = __clock_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tm"][::std::mem::size_of::<tm>() - 56usize];
    ["Alignment of tm"][::std::mem::align_of::<tm>() - 8usize];
    ["Offset of field: tm::tm_sec"][::std::mem::offset_of!(tm, tm_sec) - 0usize];
    ["Offset of field: tm::tm_min"][::std::mem::offset_of!(tm, tm_min) - 4usize];
    ["Offset of field: tm::tm_hour"][::std::mem::offset_of!(tm, tm_hour) - 8usize];
    ["Offset of field: tm::tm_mday"][::std::mem::offset_of!(tm, tm_mday) - 12usize];
    ["Offset of field: tm::tm_mon"][::std::mem::offset_of!(tm, tm_mon) - 16usize];
    ["Offset of field: tm::tm_year"][::std::mem::offset_of!(tm, tm_year) - 20usize];
    ["Offset of field: tm::tm_wday"][::std::mem::offset_of!(tm, tm_wday) - 24usize];
    ["Offset of field: tm::tm_yday"][::std::mem::offset_of!(tm, tm_yday) - 28usize];
    ["Offset of field: tm::tm_isdst"][::std::mem::offset_of!(tm, tm_isdst) - 32usize];
    ["Offset of field: tm::tm_gmtoff"][::std::mem::offset_of!(tm, tm_gmtoff) - 40usize];
    ["Offset of field: tm::tm_zone"][::std::mem::offset_of!(tm, tm_zone) - 48usize];
};
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerspec"][::std::mem::size_of::<itimerspec>() - 32usize];
    ["Alignment of itimerspec"][::std::mem::align_of::<itimerspec>() - 8usize];
    ["Offset of field: itimerspec::it_interval"]
        [::std::mem::offset_of!(itimerspec, it_interval) - 0usize];
    ["Offset of field: itimerspec::it_value"]
        [::std::mem::offset_of!(itimerspec, it_value) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::std::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::std::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::std::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::std::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::std::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::std::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::std::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn clock() -> clock_t;
}
unsafe extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
unsafe extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
unsafe extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub fn tzset();
}
unsafe extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>() - 8usize];
    ["Alignment of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>() - 4usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter"][::std::mem::size_of::<__atomic_wide_counter>() - 8usize];
    ["Alignment of __atomic_wide_counter"]
        [::std::mem::align_of::<__atomic_wide_counter>() - 8usize];
    ["Offset of field: __atomic_wide_counter::__value64"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value64) - 0usize];
    ["Offset of field: __atomic_wide_counter::__value32"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value32) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"]
        [::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"]
        [::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"]
        [::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"]
        [::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__wseq"]
        [::std::mem::offset_of!(__pthread_cond_s, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s::__g1_start"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_start) - 8usize];
    ["Offset of field: __pthread_cond_s::__g_refs"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_refs) - 16usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 32usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 36usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 40usize];
};
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __once_flag"][::std::mem::size_of::<__once_flag>() - 4usize];
    ["Alignment of __once_flag"][::std::mem::align_of::<__once_flag>() - 4usize];
    ["Offset of field: __once_flag::__data"][::std::mem::offset_of!(__once_flag, __data) - 0usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __jmp_buf_tag"][::std::mem::size_of::<__jmp_buf_tag>() - 200usize];
    ["Alignment of __jmp_buf_tag"][::std::mem::align_of::<__jmp_buf_tag>() - 8usize];
    ["Offset of field: __jmp_buf_tag::__jmpbuf"]
        [::std::mem::offset_of!(__jmp_buf_tag, __jmpbuf) - 0usize];
    ["Offset of field: __jmp_buf_tag::__mask_was_saved"]
        [::std::mem::offset_of!(__jmp_buf_tag, __mask_was_saved) - 64usize];
    ["Offset of field: __jmp_buf_tag::__saved_mask"]
        [::std::mem::offset_of!(__jmp_buf_tag, __saved_mask) - 72usize];
};
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_1 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_2 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_2 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_2 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_2 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_2 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_2 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_2 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_2 = 0;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_3 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_3 = 1;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_4 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_4 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_4 = 2;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_5 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_5 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_5 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_5 = 0;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_6 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_6 = 1;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_7 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_8 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_8 = 1;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _pthread_cleanup_buffer"][::std::mem::size_of::<_pthread_cleanup_buffer>() - 32usize];
    ["Alignment of _pthread_cleanup_buffer"]
        [::std::mem::align_of::<_pthread_cleanup_buffer>() - 8usize];
    ["Offset of field: _pthread_cleanup_buffer::__routine"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __routine) - 0usize];
    ["Offset of field: _pthread_cleanup_buffer::__arg"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __arg) - 8usize];
    ["Offset of field: _pthread_cleanup_buffer::__canceltype"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __canceltype) - 16usize];
    ["Offset of field: _pthread_cleanup_buffer::__prev"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __prev) - 24usize];
};
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_9 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_9 = 1;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_10 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_10 = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
unsafe extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_self() -> pthread_t;
}
unsafe extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __cancel_jmp_buf_tag"][::std::mem::size_of::<__cancel_jmp_buf_tag>() - 72usize];
    ["Alignment of __cancel_jmp_buf_tag"][::std::mem::align_of::<__cancel_jmp_buf_tag>() - 8usize];
    ["Offset of field: __cancel_jmp_buf_tag::__cancel_jmp_buf"]
        [::std::mem::offset_of!(__cancel_jmp_buf_tag, __cancel_jmp_buf) - 0usize];
    ["Offset of field: __cancel_jmp_buf_tag::__mask_was_saved"]
        [::std::mem::offset_of!(__cancel_jmp_buf_tag, __mask_was_saved) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_unwind_buf_t"][::std::mem::size_of::<__pthread_unwind_buf_t>() - 104usize];
    ["Alignment of __pthread_unwind_buf_t"]
        [::std::mem::align_of::<__pthread_unwind_buf_t>() - 8usize];
    ["Offset of field: __pthread_unwind_buf_t::__cancel_jmp_buf"]
        [::std::mem::offset_of!(__pthread_unwind_buf_t, __cancel_jmp_buf) - 0usize];
    ["Offset of field: __pthread_unwind_buf_t::__pad"]
        [::std::mem::offset_of!(__pthread_unwind_buf_t, __pad) - 72usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cleanup_frame"][::std::mem::size_of::<__pthread_cleanup_frame>() - 24usize];
    ["Alignment of __pthread_cleanup_frame"]
        [::std::mem::align_of::<__pthread_cleanup_frame>() - 8usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_routine"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __cancel_routine) - 0usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_arg"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __cancel_arg) - 8usize];
    ["Offset of field: __pthread_cleanup_frame::__do_it"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __do_it) - 16usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_type"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __cancel_type) - 20usize];
};
unsafe extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
unsafe extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
unsafe extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
unsafe extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type boolean = u8;
pub type int8 = i8;
pub type int16 = i16;
pub type int32 = i32;
pub type uint8 = u8;
pub type uint16 = u16;
pub type uint32 = u32;
pub type int64 = i64;
pub type uint64 = u64;
pub type float32 = f32;
pub type float64 = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_timet {
    pub sec: uint32,
    pub usec: uint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_timet"][::std::mem::size_of::<ec_timet>() - 8usize];
    ["Alignment of ec_timet"][::std::mem::align_of::<ec_timet>() - 4usize];
    ["Offset of field: ec_timet::sec"][::std::mem::offset_of!(ec_timet, sec) - 0usize];
    ["Offset of field: ec_timet::usec"][::std::mem::offset_of!(ec_timet, usec) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osal_timer {
    pub stop_time: ec_timet,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of osal_timer"][::std::mem::size_of::<osal_timer>() - 8usize];
    ["Alignment of osal_timer"][::std::mem::align_of::<osal_timer>() - 4usize];
    ["Offset of field: osal_timer::stop_time"]
        [::std::mem::offset_of!(osal_timer, stop_time) - 0usize];
};
pub type osal_timert = osal_timer;
unsafe extern "C" {
    pub fn osal_timer_start(self_: *mut osal_timert, timeout_us: uint32);
}
unsafe extern "C" {
    pub fn osal_timer_is_expired(self_: *mut osal_timert) -> boolean;
}
unsafe extern "C" {
    pub fn osal_usleep(usec: uint32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn osal_current_time() -> ec_timet;
}
unsafe extern "C" {
    pub fn osal_time_diff(start: *mut ec_timet, end: *mut ec_timet, diff: *mut ec_timet);
}
unsafe extern "C" {
    pub fn osal_thread_create(
        thandle: *mut ::std::os::raw::c_void,
        stacksize: ::std::os::raw::c_int,
        func: *mut ::std::os::raw::c_void,
        param: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn osal_thread_create_rt(
        thandle: *mut ::std::os::raw::c_void,
        stacksize: ::std::os::raw::c_int,
        func: *mut ::std::os::raw::c_void,
        param: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " definition for frame buffers"]
pub type ec_bufT = [uint8; 1518usize];
#[doc = " ethernet header definition"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ec_etherheadert {
    #[doc = " destination MAC"]
    pub da0: uint16,
    #[doc = " destination MAC"]
    pub da1: uint16,
    #[doc = " destination MAC"]
    pub da2: uint16,
    #[doc = " source MAC"]
    pub sa0: uint16,
    #[doc = " source MAC"]
    pub sa1: uint16,
    #[doc = " source MAC"]
    pub sa2: uint16,
    #[doc = " ethernet type"]
    pub etype: uint16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_etherheadert"][::std::mem::size_of::<ec_etherheadert>() - 14usize];
    ["Alignment of ec_etherheadert"][::std::mem::align_of::<ec_etherheadert>() - 1usize];
    ["Offset of field: ec_etherheadert::da0"]
        [::std::mem::offset_of!(ec_etherheadert, da0) - 0usize];
    ["Offset of field: ec_etherheadert::da1"]
        [::std::mem::offset_of!(ec_etherheadert, da1) - 2usize];
    ["Offset of field: ec_etherheadert::da2"]
        [::std::mem::offset_of!(ec_etherheadert, da2) - 4usize];
    ["Offset of field: ec_etherheadert::sa0"]
        [::std::mem::offset_of!(ec_etherheadert, sa0) - 6usize];
    ["Offset of field: ec_etherheadert::sa1"]
        [::std::mem::offset_of!(ec_etherheadert, sa1) - 8usize];
    ["Offset of field: ec_etherheadert::sa2"]
        [::std::mem::offset_of!(ec_etherheadert, sa2) - 10usize];
    ["Offset of field: ec_etherheadert::etype"]
        [::std::mem::offset_of!(ec_etherheadert, etype) - 12usize];
};
#[doc = " EtherCAT datagram header definition"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ec_comt {
    #[doc = " length of EtherCAT datagram"]
    pub elength: uint16,
    #[doc = " EtherCAT command, see ec_cmdtype"]
    pub command: uint8,
    #[doc = " index, used in SOEM for Tx to Rx recombination"]
    pub index: uint8,
    #[doc = " ADP"]
    pub ADP: uint16,
    #[doc = " ADO"]
    pub ADO: uint16,
    #[doc = " length of data portion in datagram"]
    pub dlength: uint16,
    #[doc = " interrupt, currently unused"]
    pub irpt: uint16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_comt"][::std::mem::size_of::<ec_comt>() - 12usize];
    ["Alignment of ec_comt"][::std::mem::align_of::<ec_comt>() - 1usize];
    ["Offset of field: ec_comt::elength"][::std::mem::offset_of!(ec_comt, elength) - 0usize];
    ["Offset of field: ec_comt::command"][::std::mem::offset_of!(ec_comt, command) - 2usize];
    ["Offset of field: ec_comt::index"][::std::mem::offset_of!(ec_comt, index) - 3usize];
    ["Offset of field: ec_comt::ADP"][::std::mem::offset_of!(ec_comt, ADP) - 4usize];
    ["Offset of field: ec_comt::ADO"][::std::mem::offset_of!(ec_comt, ADO) - 6usize];
    ["Offset of field: ec_comt::dlength"][::std::mem::offset_of!(ec_comt, dlength) - 8usize];
    ["Offset of field: ec_comt::irpt"][::std::mem::offset_of!(ec_comt, irpt) - 10usize];
};
#[doc = " No error"]
pub const ec_err_EC_ERR_OK: ec_err = 0;
#[doc = " Library already initialized."]
pub const ec_err_EC_ERR_ALREADY_INITIALIZED: ec_err = 1;
#[doc = " Library not initialized."]
pub const ec_err_EC_ERR_NOT_INITIALIZED: ec_err = 2;
#[doc = " Timeout occurred during execution of the function."]
pub const ec_err_EC_ERR_TIMEOUT: ec_err = 3;
#[doc = " No slaves were found."]
pub const ec_err_EC_ERR_NO_SLAVES: ec_err = 4;
#[doc = " Function failed."]
pub const ec_err_EC_ERR_NOK: ec_err = 5;
#[doc = " Possible error codes returned."]
pub type ec_err = ::std::os::raw::c_uint;
#[doc = " No valid state."]
pub const ec_state_EC_STATE_NONE: ec_state = 0;
#[doc = " Init state"]
pub const ec_state_EC_STATE_INIT: ec_state = 1;
#[doc = " Pre-operational."]
pub const ec_state_EC_STATE_PRE_OP: ec_state = 2;
#[doc = " Boot state"]
pub const ec_state_EC_STATE_BOOT: ec_state = 3;
#[doc = " Safe-operational."]
pub const ec_state_EC_STATE_SAFE_OP: ec_state = 4;
#[doc = " Operational"]
pub const ec_state_EC_STATE_OPERATIONAL: ec_state = 8;
#[doc = " Error or ACK error"]
pub const ec_state_EC_STATE_ACK: ec_state = 16;
#[doc = " Error or ACK error"]
pub const ec_state_EC_STATE_ERROR: ec_state = 16;
#[doc = " Possible EtherCAT slave states"]
pub type ec_state = ::std::os::raw::c_uint;
#[doc = " Empty"]
pub const ec_bufstate_EC_BUF_EMPTY: ec_bufstate = 0;
#[doc = " Allocated, but not filled"]
pub const ec_bufstate_EC_BUF_ALLOC: ec_bufstate = 1;
#[doc = " Transmitted"]
pub const ec_bufstate_EC_BUF_TX: ec_bufstate = 2;
#[doc = " Received, but not consumed"]
pub const ec_bufstate_EC_BUF_RCVD: ec_bufstate = 3;
#[doc = " Cycle completed"]
pub const ec_bufstate_EC_BUF_COMPLETE: ec_bufstate = 4;
#[doc = " Possible buffer states"]
pub type ec_bufstate = ::std::os::raw::c_uint;
pub const ec_datatype_ECT_BOOLEAN: ec_datatype = 1;
pub const ec_datatype_ECT_INTEGER8: ec_datatype = 2;
pub const ec_datatype_ECT_INTEGER16: ec_datatype = 3;
pub const ec_datatype_ECT_INTEGER32: ec_datatype = 4;
pub const ec_datatype_ECT_UNSIGNED8: ec_datatype = 5;
pub const ec_datatype_ECT_UNSIGNED16: ec_datatype = 6;
pub const ec_datatype_ECT_UNSIGNED32: ec_datatype = 7;
pub const ec_datatype_ECT_REAL32: ec_datatype = 8;
pub const ec_datatype_ECT_VISIBLE_STRING: ec_datatype = 9;
pub const ec_datatype_ECT_OCTET_STRING: ec_datatype = 10;
pub const ec_datatype_ECT_UNICODE_STRING: ec_datatype = 11;
pub const ec_datatype_ECT_TIME_OF_DAY: ec_datatype = 12;
pub const ec_datatype_ECT_TIME_DIFFERENCE: ec_datatype = 13;
pub const ec_datatype_ECT_DOMAIN: ec_datatype = 15;
pub const ec_datatype_ECT_INTEGER24: ec_datatype = 16;
pub const ec_datatype_ECT_REAL64: ec_datatype = 17;
pub const ec_datatype_ECT_INTEGER64: ec_datatype = 21;
pub const ec_datatype_ECT_UNSIGNED24: ec_datatype = 22;
pub const ec_datatype_ECT_UNSIGNED64: ec_datatype = 27;
pub const ec_datatype_ECT_BIT1: ec_datatype = 48;
pub const ec_datatype_ECT_BIT2: ec_datatype = 49;
pub const ec_datatype_ECT_BIT3: ec_datatype = 50;
pub const ec_datatype_ECT_BIT4: ec_datatype = 51;
pub const ec_datatype_ECT_BIT5: ec_datatype = 52;
pub const ec_datatype_ECT_BIT6: ec_datatype = 53;
pub const ec_datatype_ECT_BIT7: ec_datatype = 54;
pub const ec_datatype_ECT_BIT8: ec_datatype = 55;
#[doc = " Ethercat data types"]
pub type ec_datatype = ::std::os::raw::c_uint;
#[doc = " No operation"]
pub const ec_cmdtype_EC_CMD_NOP: ec_cmdtype = 0;
#[doc = " Auto Increment Read"]
pub const ec_cmdtype_EC_CMD_APRD: ec_cmdtype = 1;
#[doc = " Auto Increment Write"]
pub const ec_cmdtype_EC_CMD_APWR: ec_cmdtype = 2;
#[doc = " Auto Increment Read Write"]
pub const ec_cmdtype_EC_CMD_APRW: ec_cmdtype = 3;
#[doc = " Configured Address Read"]
pub const ec_cmdtype_EC_CMD_FPRD: ec_cmdtype = 4;
#[doc = " Configured Address Write"]
pub const ec_cmdtype_EC_CMD_FPWR: ec_cmdtype = 5;
#[doc = " Configured Address Read Write"]
pub const ec_cmdtype_EC_CMD_FPRW: ec_cmdtype = 6;
#[doc = " Broadcast Read"]
pub const ec_cmdtype_EC_CMD_BRD: ec_cmdtype = 7;
#[doc = " Broadcast Write"]
pub const ec_cmdtype_EC_CMD_BWR: ec_cmdtype = 8;
#[doc = " Broadcast Read Write"]
pub const ec_cmdtype_EC_CMD_BRW: ec_cmdtype = 9;
#[doc = " Logical Memory Read"]
pub const ec_cmdtype_EC_CMD_LRD: ec_cmdtype = 10;
#[doc = " Logical Memory Write"]
pub const ec_cmdtype_EC_CMD_LWR: ec_cmdtype = 11;
#[doc = " Logical Memory Read Write"]
pub const ec_cmdtype_EC_CMD_LRW: ec_cmdtype = 12;
#[doc = " Auto Increment Read Multiple Write"]
pub const ec_cmdtype_EC_CMD_ARMW: ec_cmdtype = 13;
#[doc = " Configured Read Multiple Write"]
pub const ec_cmdtype_EC_CMD_FRMW: ec_cmdtype = 14;
#[doc = " Ethercat command types"]
pub type ec_cmdtype = ::std::os::raw::c_uint;
#[doc = " No operation"]
pub const ec_ecmdtype_EC_ECMD_NOP: ec_ecmdtype = 0;
#[doc = " Read"]
pub const ec_ecmdtype_EC_ECMD_READ: ec_ecmdtype = 256;
#[doc = " Write"]
pub const ec_ecmdtype_EC_ECMD_WRITE: ec_ecmdtype = 513;
#[doc = " Reload"]
pub const ec_ecmdtype_EC_ECMD_RELOAD: ec_ecmdtype = 768;
#[doc = " Ethercat EEprom command types"]
pub type ec_ecmdtype = ::std::os::raw::c_uint;
#[doc = " SII category strings"]
pub const ECT_SII_STRING: _bindgen_ty_11 = 10;
#[doc = " SII category general"]
pub const ECT_SII_GENERAL: _bindgen_ty_11 = 30;
#[doc = " SII category FMMU"]
pub const ECT_SII_FMMU: _bindgen_ty_11 = 40;
#[doc = " SII category SM"]
pub const ECT_SII_SM: _bindgen_ty_11 = 41;
#[doc = " SII category PDO"]
pub const ECT_SII_PDO: _bindgen_ty_11 = 50;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const ECT_SII_MANUF: _bindgen_ty_12 = 8;
pub const ECT_SII_ID: _bindgen_ty_12 = 10;
pub const ECT_SII_REV: _bindgen_ty_12 = 12;
pub const ECT_SII_SN: _bindgen_ty_12 = 14;
pub const ECT_SII_BOOTRXMBX: _bindgen_ty_12 = 20;
pub const ECT_SII_BOOTTXMBX: _bindgen_ty_12 = 22;
pub const ECT_SII_MBXSIZE: _bindgen_ty_12 = 25;
pub const ECT_SII_TXMBXADR: _bindgen_ty_12 = 26;
pub const ECT_SII_RXMBXADR: _bindgen_ty_12 = 24;
pub const ECT_SII_MBXPROTO: _bindgen_ty_12 = 28;
#[doc = " Item offsets in SII general section"]
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
#[doc = " Error mailbox type"]
pub const ECT_MBXT_ERR: _bindgen_ty_13 = 0;
#[doc = " ADS over EtherCAT mailbox type"]
pub const ECT_MBXT_AOE: _bindgen_ty_13 = 1;
#[doc = " Ethernet over EtherCAT mailbox type"]
pub const ECT_MBXT_EOE: _bindgen_ty_13 = 2;
#[doc = " CANopen over EtherCAT mailbox type"]
pub const ECT_MBXT_COE: _bindgen_ty_13 = 3;
#[doc = " File over EtherCAT mailbox type"]
pub const ECT_MBXT_FOE: _bindgen_ty_13 = 4;
#[doc = " Servo over EtherCAT mailbox type"]
pub const ECT_MBXT_SOE: _bindgen_ty_13 = 5;
#[doc = " Vendor over EtherCAT mailbox type"]
pub const ECT_MBXT_VOE: _bindgen_ty_13 = 15;
#[doc = " Mailbox types definitions"]
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const ECT_COES_EMERGENCY: _bindgen_ty_14 = 1;
pub const ECT_COES_SDOREQ: _bindgen_ty_14 = 2;
pub const ECT_COES_SDORES: _bindgen_ty_14 = 3;
pub const ECT_COES_TXPDO: _bindgen_ty_14 = 4;
pub const ECT_COES_RXPDO: _bindgen_ty_14 = 5;
pub const ECT_COES_TXPDO_RR: _bindgen_ty_14 = 6;
pub const ECT_COES_RXPDO_RR: _bindgen_ty_14 = 7;
pub const ECT_COES_SDOINFO: _bindgen_ty_14 = 8;
#[doc = " CoE mailbox types"]
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const ECT_SDO_DOWN_INIT: _bindgen_ty_15 = 33;
pub const ECT_SDO_DOWN_EXP: _bindgen_ty_15 = 35;
pub const ECT_SDO_DOWN_INIT_CA: _bindgen_ty_15 = 49;
pub const ECT_SDO_UP_REQ: _bindgen_ty_15 = 64;
pub const ECT_SDO_UP_REQ_CA: _bindgen_ty_15 = 80;
pub const ECT_SDO_SEG_UP_REQ: _bindgen_ty_15 = 96;
pub const ECT_SDO_ABORT: _bindgen_ty_15 = 128;
#[doc = " CoE SDO commands"]
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const ECT_GET_ODLIST_REQ: _bindgen_ty_16 = 1;
pub const ECT_GET_ODLIST_RES: _bindgen_ty_16 = 2;
pub const ECT_GET_OD_REQ: _bindgen_ty_16 = 3;
pub const ECT_GET_OD_RES: _bindgen_ty_16 = 4;
pub const ECT_GET_OE_REQ: _bindgen_ty_16 = 5;
pub const ECT_GET_OE_RES: _bindgen_ty_16 = 6;
pub const ECT_SDOINFO_ERROR: _bindgen_ty_16 = 7;
#[doc = " CoE Object Description commands"]
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const ECT_FOE_READ: _bindgen_ty_17 = 1;
pub const ECT_FOE_WRITE: _bindgen_ty_17 = 2;
pub const ECT_FOE_DATA: _bindgen_ty_17 = 3;
pub const ECT_FOE_ACK: _bindgen_ty_17 = 4;
pub const ECT_FOE_ERROR: _bindgen_ty_17 = 5;
pub const ECT_FOE_BUSY: _bindgen_ty_17 = 6;
#[doc = " FoE opcodes"]
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const ECT_SOE_READREQ: _bindgen_ty_18 = 1;
pub const ECT_SOE_READRES: _bindgen_ty_18 = 2;
pub const ECT_SOE_WRITEREQ: _bindgen_ty_18 = 3;
pub const ECT_SOE_WRITERES: _bindgen_ty_18 = 4;
pub const ECT_SOE_NOTIFICATION: _bindgen_ty_18 = 5;
pub const ECT_SOE_EMERGENCY: _bindgen_ty_18 = 6;
#[doc = " SoE opcodes"]
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
pub const ECT_REG_TYPE: _bindgen_ty_19 = 0;
pub const ECT_REG_PORTDES: _bindgen_ty_19 = 7;
pub const ECT_REG_ESCSUP: _bindgen_ty_19 = 8;
pub const ECT_REG_STADR: _bindgen_ty_19 = 16;
pub const ECT_REG_ALIAS: _bindgen_ty_19 = 18;
pub const ECT_REG_DLCTL: _bindgen_ty_19 = 256;
pub const ECT_REG_DLPORT: _bindgen_ty_19 = 257;
pub const ECT_REG_DLALIAS: _bindgen_ty_19 = 259;
pub const ECT_REG_DLSTAT: _bindgen_ty_19 = 272;
pub const ECT_REG_ALCTL: _bindgen_ty_19 = 288;
pub const ECT_REG_ALSTAT: _bindgen_ty_19 = 304;
pub const ECT_REG_ALSTATCODE: _bindgen_ty_19 = 308;
pub const ECT_REG_PDICTL: _bindgen_ty_19 = 320;
pub const ECT_REG_IRQMASK: _bindgen_ty_19 = 512;
pub const ECT_REG_RXERR: _bindgen_ty_19 = 768;
pub const ECT_REG_FRXERR: _bindgen_ty_19 = 776;
pub const ECT_REG_EPUECNT: _bindgen_ty_19 = 780;
pub const ECT_REG_PECNT: _bindgen_ty_19 = 781;
pub const ECT_REG_PECODE: _bindgen_ty_19 = 782;
pub const ECT_REG_LLCNT: _bindgen_ty_19 = 784;
pub const ECT_REG_WDCNT: _bindgen_ty_19 = 1090;
pub const ECT_REG_EEPCFG: _bindgen_ty_19 = 1280;
pub const ECT_REG_EEPCTL: _bindgen_ty_19 = 1282;
pub const ECT_REG_EEPSTAT: _bindgen_ty_19 = 1282;
pub const ECT_REG_EEPADR: _bindgen_ty_19 = 1284;
pub const ECT_REG_EEPDAT: _bindgen_ty_19 = 1288;
pub const ECT_REG_FMMU0: _bindgen_ty_19 = 1536;
pub const ECT_REG_FMMU1: _bindgen_ty_19 = 1552;
pub const ECT_REG_FMMU2: _bindgen_ty_19 = 1568;
pub const ECT_REG_FMMU3: _bindgen_ty_19 = 1584;
pub const ECT_REG_SM0: _bindgen_ty_19 = 2048;
pub const ECT_REG_SM1: _bindgen_ty_19 = 2056;
pub const ECT_REG_SM2: _bindgen_ty_19 = 2064;
pub const ECT_REG_SM3: _bindgen_ty_19 = 2072;
pub const ECT_REG_SM0STAT: _bindgen_ty_19 = 2053;
pub const ECT_REG_SM1STAT: _bindgen_ty_19 = 2061;
pub const ECT_REG_SM1ACT: _bindgen_ty_19 = 2062;
pub const ECT_REG_SM1CONTR: _bindgen_ty_19 = 2063;
pub const ECT_REG_DCTIME0: _bindgen_ty_19 = 2304;
pub const ECT_REG_DCTIME1: _bindgen_ty_19 = 2308;
pub const ECT_REG_DCTIME2: _bindgen_ty_19 = 2312;
pub const ECT_REG_DCTIME3: _bindgen_ty_19 = 2316;
pub const ECT_REG_DCSYSTIME: _bindgen_ty_19 = 2320;
pub const ECT_REG_DCSOF: _bindgen_ty_19 = 2328;
pub const ECT_REG_DCSYSOFFSET: _bindgen_ty_19 = 2336;
pub const ECT_REG_DCSYSDELAY: _bindgen_ty_19 = 2344;
pub const ECT_REG_DCSYSDIFF: _bindgen_ty_19 = 2348;
pub const ECT_REG_DCSPEEDCNT: _bindgen_ty_19 = 2352;
pub const ECT_REG_DCTIMEFILT: _bindgen_ty_19 = 2356;
pub const ECT_REG_DCCUC: _bindgen_ty_19 = 2432;
pub const ECT_REG_DCSYNCACT: _bindgen_ty_19 = 2433;
pub const ECT_REG_DCSTART0: _bindgen_ty_19 = 2448;
pub const ECT_REG_DCCYCLE0: _bindgen_ty_19 = 2464;
pub const ECT_REG_DCCYCLE1: _bindgen_ty_19 = 2468;
#[doc = " Ethercat registers"]
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const ec_err_type_EC_ERR_TYPE_SDO_ERROR: ec_err_type = 0;
pub const ec_err_type_EC_ERR_TYPE_EMERGENCY: ec_err_type = 1;
pub const ec_err_type_EC_ERR_TYPE_PACKET_ERROR: ec_err_type = 3;
pub const ec_err_type_EC_ERR_TYPE_SDOINFO_ERROR: ec_err_type = 4;
pub const ec_err_type_EC_ERR_TYPE_FOE_ERROR: ec_err_type = 5;
pub const ec_err_type_EC_ERR_TYPE_FOE_BUF2SMALL: ec_err_type = 6;
pub const ec_err_type_EC_ERR_TYPE_FOE_PACKETNUMBER: ec_err_type = 7;
pub const ec_err_type_EC_ERR_TYPE_SOE_ERROR: ec_err_type = 8;
pub const ec_err_type_EC_ERR_TYPE_MBX_ERROR: ec_err_type = 9;
pub const ec_err_type_EC_ERR_TYPE_FOE_FILE_NOTFOUND: ec_err_type = 10;
pub const ec_err_type_EC_ERR_TYPE_EOE_INVALID_RX_DATA: ec_err_type = 11;
#[doc = " Error types"]
pub type ec_err_type = ::std::os::raw::c_uint;
#[doc = " Struct to retrieve errors."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_errort {
    #[doc = " Time at which the error was generated."]
    pub Time: ec_timet,
    #[doc = " Signal bit, error set but not read"]
    pub Signal: boolean,
    #[doc = " Slave number that generated the error"]
    pub Slave: uint16,
    #[doc = " CoE SDO index that generated the error"]
    pub Index: uint16,
    #[doc = " CoE SDO subindex that generated the error"]
    pub SubIdx: uint8,
    #[doc = " Type of error"]
    pub Etype: ec_err_type,
    pub __bindgen_anon_1: ec_errort__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ec_errort__bindgen_ty_1 {
    #[doc = " General abortcode"]
    pub AbortCode: int32,
    pub __bindgen_anon_1: ec_errort__bindgen_ty_1__bindgen_ty_1,
}
#[doc = " Specific error for Emergency mailbox"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_errort__bindgen_ty_1__bindgen_ty_1 {
    pub ErrorCode: uint16,
    pub ErrorReg: uint8,
    pub b1: uint8,
    pub w1: uint16,
    pub w2: uint16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_errort__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<ec_errort__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of ec_errort__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<ec_errort__bindgen_ty_1__bindgen_ty_1>() - 2usize];
    ["Offset of field: ec_errort__bindgen_ty_1__bindgen_ty_1::ErrorCode"]
        [::std::mem::offset_of!(ec_errort__bindgen_ty_1__bindgen_ty_1, ErrorCode) - 0usize];
    ["Offset of field: ec_errort__bindgen_ty_1__bindgen_ty_1::ErrorReg"]
        [::std::mem::offset_of!(ec_errort__bindgen_ty_1__bindgen_ty_1, ErrorReg) - 2usize];
    ["Offset of field: ec_errort__bindgen_ty_1__bindgen_ty_1::b1"]
        [::std::mem::offset_of!(ec_errort__bindgen_ty_1__bindgen_ty_1, b1) - 3usize];
    ["Offset of field: ec_errort__bindgen_ty_1__bindgen_ty_1::w1"]
        [::std::mem::offset_of!(ec_errort__bindgen_ty_1__bindgen_ty_1, w1) - 4usize];
    ["Offset of field: ec_errort__bindgen_ty_1__bindgen_ty_1::w2"]
        [::std::mem::offset_of!(ec_errort__bindgen_ty_1__bindgen_ty_1, w2) - 6usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_errort__bindgen_ty_1"][::std::mem::size_of::<ec_errort__bindgen_ty_1>() - 8usize];
    ["Alignment of ec_errort__bindgen_ty_1"]
        [::std::mem::align_of::<ec_errort__bindgen_ty_1>() - 4usize];
    ["Offset of field: ec_errort__bindgen_ty_1::AbortCode"]
        [::std::mem::offset_of!(ec_errort__bindgen_ty_1, AbortCode) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_errort"][::std::mem::size_of::<ec_errort>() - 28usize];
    ["Alignment of ec_errort"][::std::mem::align_of::<ec_errort>() - 4usize];
    ["Offset of field: ec_errort::Time"][::std::mem::offset_of!(ec_errort, Time) - 0usize];
    ["Offset of field: ec_errort::Signal"][::std::mem::offset_of!(ec_errort, Signal) - 8usize];
    ["Offset of field: ec_errort::Slave"][::std::mem::offset_of!(ec_errort, Slave) - 10usize];
    ["Offset of field: ec_errort::Index"][::std::mem::offset_of!(ec_errort, Index) - 12usize];
    ["Offset of field: ec_errort::SubIdx"][::std::mem::offset_of!(ec_errort, SubIdx) - 14usize];
    ["Offset of field: ec_errort::Etype"][::std::mem::offset_of!(ec_errort, Etype) - 16usize];
};
#[doc = " pointer structure to Tx and Rx stacks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_stackT {
    #[doc = " socket connection used"]
    pub sock: *mut ::std::os::raw::c_int,
    #[doc = " tx buffer"]
    pub txbuf: *mut [ec_bufT; 16usize],
    #[doc = " tx buffer lengths"]
    pub txbuflength: *mut [::std::os::raw::c_int; 16usize],
    #[doc = " temporary receive buffer"]
    pub tempbuf: *mut ec_bufT,
    #[doc = " rx buffers"]
    pub rxbuf: *mut [ec_bufT; 16usize],
    #[doc = " rx buffer status fields"]
    pub rxbufstat: *mut [::std::os::raw::c_int; 16usize],
    #[doc = " received MAC source address (middle word)"]
    pub rxsa: *mut [::std::os::raw::c_int; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_stackT"][::std::mem::size_of::<ec_stackT>() - 56usize];
    ["Alignment of ec_stackT"][::std::mem::align_of::<ec_stackT>() - 8usize];
    ["Offset of field: ec_stackT::sock"][::std::mem::offset_of!(ec_stackT, sock) - 0usize];
    ["Offset of field: ec_stackT::txbuf"][::std::mem::offset_of!(ec_stackT, txbuf) - 8usize];
    ["Offset of field: ec_stackT::txbuflength"]
        [::std::mem::offset_of!(ec_stackT, txbuflength) - 16usize];
    ["Offset of field: ec_stackT::tempbuf"][::std::mem::offset_of!(ec_stackT, tempbuf) - 24usize];
    ["Offset of field: ec_stackT::rxbuf"][::std::mem::offset_of!(ec_stackT, rxbuf) - 32usize];
    ["Offset of field: ec_stackT::rxbufstat"]
        [::std::mem::offset_of!(ec_stackT, rxbufstat) - 40usize];
    ["Offset of field: ec_stackT::rxsa"][::std::mem::offset_of!(ec_stackT, rxsa) - 48usize];
};
#[doc = " pointer structure to buffers for redundant port"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecx_redportt {
    pub stack: ec_stackT,
    pub sockhandle: ::std::os::raw::c_int,
    #[doc = " rx buffers"]
    pub rxbuf: [ec_bufT; 16usize],
    #[doc = " rx buffer status"]
    pub rxbufstat: [::std::os::raw::c_int; 16usize],
    #[doc = " rx MAC source address"]
    pub rxsa: [::std::os::raw::c_int; 16usize],
    #[doc = " temporary rx buffer"]
    pub tempinbuf: ec_bufT,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecx_redportt"][::std::mem::size_of::<ecx_redportt>() - 26000usize];
    ["Alignment of ecx_redportt"][::std::mem::align_of::<ecx_redportt>() - 8usize];
    ["Offset of field: ecx_redportt::stack"][::std::mem::offset_of!(ecx_redportt, stack) - 0usize];
    ["Offset of field: ecx_redportt::sockhandle"]
        [::std::mem::offset_of!(ecx_redportt, sockhandle) - 56usize];
    ["Offset of field: ecx_redportt::rxbuf"][::std::mem::offset_of!(ecx_redportt, rxbuf) - 60usize];
    ["Offset of field: ecx_redportt::rxbufstat"]
        [::std::mem::offset_of!(ecx_redportt, rxbufstat) - 24348usize];
    ["Offset of field: ecx_redportt::rxsa"]
        [::std::mem::offset_of!(ecx_redportt, rxsa) - 24412usize];
    ["Offset of field: ecx_redportt::tempinbuf"]
        [::std::mem::offset_of!(ecx_redportt, tempinbuf) - 24476usize];
};
#[doc = " pointer structure to buffers, vars and mutexes for port instantiation"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecx_portt {
    pub stack: ec_stackT,
    pub sockhandle: ::std::os::raw::c_int,
    #[doc = " rx buffers"]
    pub rxbuf: [ec_bufT; 16usize],
    #[doc = " rx buffer status"]
    pub rxbufstat: [::std::os::raw::c_int; 16usize],
    #[doc = " rx MAC source address"]
    pub rxsa: [::std::os::raw::c_int; 16usize],
    #[doc = " temporary rx buffer"]
    pub tempinbuf: ec_bufT,
    #[doc = " temporary rx buffer status"]
    pub tempinbufs: ::std::os::raw::c_int,
    #[doc = " transmit buffers"]
    pub txbuf: [ec_bufT; 16usize],
    #[doc = " transmit buffer lengths"]
    pub txbuflength: [::std::os::raw::c_int; 16usize],
    #[doc = " temporary tx buffer"]
    pub txbuf2: ec_bufT,
    #[doc = " temporary tx buffer length"]
    pub txbuflength2: ::std::os::raw::c_int,
    #[doc = " last used frame index"]
    pub lastidx: uint8,
    #[doc = " current redundancy state"]
    pub redstate: ::std::os::raw::c_int,
    #[doc = " pointer to redundancy port and buffers"]
    pub redport: *mut ecx_redportt,
    pub getindex_mutex: pthread_mutex_t,
    pub tx_mutex: pthread_mutex_t,
    pub rx_mutex: pthread_mutex_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecx_portt"][::std::mem::size_of::<ecx_portt>() - 52016usize];
    ["Alignment of ecx_portt"][::std::mem::align_of::<ecx_portt>() - 8usize];
    ["Offset of field: ecx_portt::stack"][::std::mem::offset_of!(ecx_portt, stack) - 0usize];
    ["Offset of field: ecx_portt::sockhandle"]
        [::std::mem::offset_of!(ecx_portt, sockhandle) - 56usize];
    ["Offset of field: ecx_portt::rxbuf"][::std::mem::offset_of!(ecx_portt, rxbuf) - 60usize];
    ["Offset of field: ecx_portt::rxbufstat"]
        [::std::mem::offset_of!(ecx_portt, rxbufstat) - 24348usize];
    ["Offset of field: ecx_portt::rxsa"][::std::mem::offset_of!(ecx_portt, rxsa) - 24412usize];
    ["Offset of field: ecx_portt::tempinbuf"]
        [::std::mem::offset_of!(ecx_portt, tempinbuf) - 24476usize];
    ["Offset of field: ecx_portt::tempinbufs"]
        [::std::mem::offset_of!(ecx_portt, tempinbufs) - 25996usize];
    ["Offset of field: ecx_portt::txbuf"][::std::mem::offset_of!(ecx_portt, txbuf) - 26000usize];
    ["Offset of field: ecx_portt::txbuflength"]
        [::std::mem::offset_of!(ecx_portt, txbuflength) - 50288usize];
    ["Offset of field: ecx_portt::txbuf2"][::std::mem::offset_of!(ecx_portt, txbuf2) - 50352usize];
    ["Offset of field: ecx_portt::txbuflength2"]
        [::std::mem::offset_of!(ecx_portt, txbuflength2) - 51872usize];
    ["Offset of field: ecx_portt::lastidx"]
        [::std::mem::offset_of!(ecx_portt, lastidx) - 51876usize];
    ["Offset of field: ecx_portt::redstate"]
        [::std::mem::offset_of!(ecx_portt, redstate) - 51880usize];
    ["Offset of field: ecx_portt::redport"]
        [::std::mem::offset_of!(ecx_portt, redport) - 51888usize];
    ["Offset of field: ecx_portt::getindex_mutex"]
        [::std::mem::offset_of!(ecx_portt, getindex_mutex) - 51896usize];
    ["Offset of field: ecx_portt::tx_mutex"]
        [::std::mem::offset_of!(ecx_portt, tx_mutex) - 51936usize];
    ["Offset of field: ecx_portt::rx_mutex"]
        [::std::mem::offset_of!(ecx_portt, rx_mutex) - 51976usize];
};
unsafe extern "C" {
    pub static priMAC: [uint16; 3usize];
}
unsafe extern "C" {
    pub static secMAC: [uint16; 3usize];
}
unsafe extern "C" {
    pub static mut ecx_port: ecx_portt;
}
unsafe extern "C" {
    pub static mut ecx_redport: ecx_redportt;
}
unsafe extern "C" {
    pub fn ec_setupnic(
        ifname: *const ::std::os::raw::c_char,
        secondary: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_closenic() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_setbufstat(idx: uint8, bufstat: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ec_getindex() -> uint8;
}
unsafe extern "C" {
    pub fn ec_outframe(idx: uint8, sock: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_outframe_red(idx: uint8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_waitinframe(idx: uint8, timeout: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_srconfirm(idx: uint8, timeout: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_setupheader(p: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn ecx_setupnic(
        port: *mut ecx_portt,
        ifname: *const ::std::os::raw::c_char,
        secondary: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_closenic(port: *mut ecx_portt) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_setbufstat(port: *mut ecx_portt, idx: uint8, bufstat: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn ecx_getindex(port: *mut ecx_portt) -> uint8;
}
unsafe extern "C" {
    pub fn ecx_outframe(
        port: *mut ecx_portt,
        idx: uint8,
        sock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_outframe_red(port: *mut ecx_portt, idx: uint8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_waitinframe(
        port: *mut ecx_portt,
        idx: uint8,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_srconfirm(
        port: *mut ecx_portt,
        idx: uint8,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_setupdatagram(
        port: *mut ecx_portt,
        frame: *mut ::std::os::raw::c_void,
        com: uint8,
        idx: uint8,
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_adddatagram(
        port: *mut ecx_portt,
        frame: *mut ::std::os::raw::c_void,
        com: uint8,
        idx: uint8,
        more: boolean,
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
    ) -> uint16;
}
unsafe extern "C" {
    pub fn ecx_BWR(
        port: *mut ecx_portt,
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_BRD(
        port: *mut ecx_portt,
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_APRD(
        port: *mut ecx_portt,
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_ARMW(
        port: *mut ecx_portt,
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_FRMW(
        port: *mut ecx_portt,
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_APRDw(
        port: *mut ecx_portt,
        ADP: uint16,
        ADO: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> uint16;
}
unsafe extern "C" {
    pub fn ecx_FPRD(
        port: *mut ecx_portt,
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_FPRDw(
        port: *mut ecx_portt,
        ADP: uint16,
        ADO: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> uint16;
}
unsafe extern "C" {
    pub fn ecx_APWRw(
        port: *mut ecx_portt,
        ADP: uint16,
        ADO: uint16,
        data: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_APWR(
        port: *mut ecx_portt,
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_FPWRw(
        port: *mut ecx_portt,
        ADP: uint16,
        ADO: uint16,
        data: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_FPWR(
        port: *mut ecx_portt,
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_LRW(
        port: *mut ecx_portt,
        LogAdr: uint32,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_LRD(
        port: *mut ecx_portt,
        LogAdr: uint32,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_LWR(
        port: *mut ecx_portt,
        LogAdr: uint32,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_LRWDC(
        port: *mut ecx_portt,
        LogAdr: uint32,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        DCrs: uint16,
        DCtime: *mut int64,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_setupdatagram(
        frame: *mut ::std::os::raw::c_void,
        com: uint8,
        idx: uint8,
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_adddatagram(
        frame: *mut ::std::os::raw::c_void,
        com: uint8,
        idx: uint8,
        more: boolean,
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
    ) -> uint16;
}
unsafe extern "C" {
    pub fn ec_BWR(
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_BRD(
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_APRD(
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_ARMW(
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_FRMW(
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_APRDw(ADP: uint16, ADO: uint16, timeout: ::std::os::raw::c_int) -> uint16;
}
unsafe extern "C" {
    pub fn ec_FPRD(
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_FPRDw(ADP: uint16, ADO: uint16, timeout: ::std::os::raw::c_int) -> uint16;
}
unsafe extern "C" {
    pub fn ec_APWRw(
        ADP: uint16,
        ADO: uint16,
        data: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_APWR(
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_FPWRw(
        ADP: uint16,
        ADO: uint16,
        data: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_FPWR(
        ADP: uint16,
        ADO: uint16,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_LRW(
        LogAdr: uint32,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_LRD(
        LogAdr: uint32,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_LWR(
        LogAdr: uint32,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_LRWDC(
        LogAdr: uint32,
        length: uint16,
        data: *mut ::std::os::raw::c_void,
        DCrs: uint16,
        DCtime: *mut int64,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type ec_adaptert = ec_adapter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_adapter {
    pub name: [::std::os::raw::c_char; 128usize],
    pub desc: [::std::os::raw::c_char; 128usize],
    pub next: *mut ec_adaptert,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_adapter"][::std::mem::size_of::<ec_adapter>() - 264usize];
    ["Alignment of ec_adapter"][::std::mem::align_of::<ec_adapter>() - 8usize];
    ["Offset of field: ec_adapter::name"][::std::mem::offset_of!(ec_adapter, name) - 0usize];
    ["Offset of field: ec_adapter::desc"][::std::mem::offset_of!(ec_adapter, desc) - 128usize];
    ["Offset of field: ec_adapter::next"][::std::mem::offset_of!(ec_adapter, next) - 256usize];
};
#[doc = " record for FMMU"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ec_fmmu {
    pub LogStart: uint32,
    pub LogLength: uint16,
    pub LogStartbit: uint8,
    pub LogEndbit: uint8,
    pub PhysStart: uint16,
    pub PhysStartBit: uint8,
    pub FMMUtype: uint8,
    pub FMMUactive: uint8,
    pub unused1: uint8,
    pub unused2: uint16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_fmmu"][::std::mem::size_of::<ec_fmmu>() - 16usize];
    ["Alignment of ec_fmmu"][::std::mem::align_of::<ec_fmmu>() - 1usize];
    ["Offset of field: ec_fmmu::LogStart"][::std::mem::offset_of!(ec_fmmu, LogStart) - 0usize];
    ["Offset of field: ec_fmmu::LogLength"][::std::mem::offset_of!(ec_fmmu, LogLength) - 4usize];
    ["Offset of field: ec_fmmu::LogStartbit"]
        [::std::mem::offset_of!(ec_fmmu, LogStartbit) - 6usize];
    ["Offset of field: ec_fmmu::LogEndbit"][::std::mem::offset_of!(ec_fmmu, LogEndbit) - 7usize];
    ["Offset of field: ec_fmmu::PhysStart"][::std::mem::offset_of!(ec_fmmu, PhysStart) - 8usize];
    ["Offset of field: ec_fmmu::PhysStartBit"]
        [::std::mem::offset_of!(ec_fmmu, PhysStartBit) - 10usize];
    ["Offset of field: ec_fmmu::FMMUtype"][::std::mem::offset_of!(ec_fmmu, FMMUtype) - 11usize];
    ["Offset of field: ec_fmmu::FMMUactive"][::std::mem::offset_of!(ec_fmmu, FMMUactive) - 12usize];
    ["Offset of field: ec_fmmu::unused1"][::std::mem::offset_of!(ec_fmmu, unused1) - 13usize];
    ["Offset of field: ec_fmmu::unused2"][::std::mem::offset_of!(ec_fmmu, unused2) - 14usize];
};
#[doc = " record for FMMU"]
pub type ec_fmmut = ec_fmmu;
#[doc = " record for sync manager"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ec_sm {
    pub StartAddr: uint16,
    pub SMlength: uint16,
    pub SMflags: uint32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_sm"][::std::mem::size_of::<ec_sm>() - 8usize];
    ["Alignment of ec_sm"][::std::mem::align_of::<ec_sm>() - 1usize];
    ["Offset of field: ec_sm::StartAddr"][::std::mem::offset_of!(ec_sm, StartAddr) - 0usize];
    ["Offset of field: ec_sm::SMlength"][::std::mem::offset_of!(ec_sm, SMlength) - 2usize];
    ["Offset of field: ec_sm::SMflags"][::std::mem::offset_of!(ec_sm, SMflags) - 4usize];
};
#[doc = " record for sync manager"]
pub type ec_smt = ec_sm;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ec_state_status {
    pub State: uint16,
    pub Unused: uint16,
    pub ALstatuscode: uint16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_state_status"][::std::mem::size_of::<ec_state_status>() - 6usize];
    ["Alignment of ec_state_status"][::std::mem::align_of::<ec_state_status>() - 1usize];
    ["Offset of field: ec_state_status::State"]
        [::std::mem::offset_of!(ec_state_status, State) - 0usize];
    ["Offset of field: ec_state_status::Unused"]
        [::std::mem::offset_of!(ec_state_status, Unused) - 2usize];
    ["Offset of field: ec_state_status::ALstatuscode"]
        [::std::mem::offset_of!(ec_state_status, ALstatuscode) - 4usize];
};
#[doc = " Context structure , referenced by all ecx functions"]
pub type ecx_contextt = ecx_context;
#[doc = " for list of ethercat slaves detected"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_slave {
    #[doc = " state of slave"]
    pub state: uint16,
    #[doc = " AL status code"]
    pub ALstatuscode: uint16,
    #[doc = " Configured address"]
    pub configadr: uint16,
    #[doc = " Alias address"]
    pub aliasadr: uint16,
    #[doc = " Manufacturer from EEprom"]
    pub eep_man: uint32,
    #[doc = " ID from EEprom"]
    pub eep_id: uint32,
    #[doc = " revision from EEprom"]
    pub eep_rev: uint32,
    #[doc = " serial number from EEprom"]
    pub eep_sn: uint32,
    #[doc = " Interface type"]
    pub Itype: uint16,
    #[doc = " Device type"]
    pub Dtype: uint16,
    #[doc = " output bits"]
    pub Obits: uint16,
    #[doc = " output bytes, if Obits < 8 then Obytes = 0"]
    pub Obytes: uint32,
    #[doc = " output pointer in IOmap buffer"]
    pub outputs: *mut uint8,
    #[doc = " startbit in first output byte"]
    pub Ostartbit: uint8,
    #[doc = " input bits"]
    pub Ibits: uint16,
    #[doc = " input bytes, if Ibits < 8 then Ibytes = 0"]
    pub Ibytes: uint32,
    #[doc = " input pointer in IOmap buffer"]
    pub inputs: *mut uint8,
    #[doc = " startbit in first input byte"]
    pub Istartbit: uint8,
    #[doc = " SM structure"]
    pub SM: [ec_smt; 8usize],
    #[doc = " SM type 0=unused 1=MbxWr 2=MbxRd 3=Outputs 4=Inputs"]
    pub SMtype: [uint8; 8usize],
    #[doc = " FMMU structure"]
    pub FMMU: [ec_fmmut; 4usize],
    #[doc = " FMMU0 function"]
    pub FMMU0func: uint8,
    #[doc = " FMMU1 function"]
    pub FMMU1func: uint8,
    #[doc = " FMMU2 function"]
    pub FMMU2func: uint8,
    #[doc = " FMMU3 function"]
    pub FMMU3func: uint8,
    #[doc = " length of write mailbox in bytes, if no mailbox then 0"]
    pub mbx_l: uint16,
    #[doc = " mailbox write offset"]
    pub mbx_wo: uint16,
    #[doc = " length of read mailbox in bytes"]
    pub mbx_rl: uint16,
    #[doc = " mailbox read offset"]
    pub mbx_ro: uint16,
    #[doc = " mailbox supported protocols"]
    pub mbx_proto: uint16,
    #[doc = " Counter value of mailbox link layer protocol 1..7"]
    pub mbx_cnt: uint8,
    #[doc = " has DC capability"]
    pub hasdc: boolean,
    #[doc = " Physical type; Ebus, EtherNet combinations"]
    pub ptype: uint8,
    #[doc = " topology: 1 to 3 links"]
    pub topology: uint8,
    #[doc = " active ports bitmap : ....3210 , set if respective port is active"]
    pub activeports: uint8,
    #[doc = " consumed ports bitmap : ....3210, used for internal delay measurement"]
    pub consumedports: uint8,
    #[doc = " slave number for parent, 0=master"]
    pub parent: uint16,
    #[doc = " port number on parent this slave is connected to"]
    pub parentport: uint8,
    #[doc = " port number on this slave the parent is connected to"]
    pub entryport: uint8,
    #[doc = " DC receivetimes on port A"]
    pub DCrtA: int32,
    #[doc = " DC receivetimes on port B"]
    pub DCrtB: int32,
    #[doc = " DC receivetimes on port C"]
    pub DCrtC: int32,
    #[doc = " DC receivetimes on port D"]
    pub DCrtD: int32,
    #[doc = " propagation delay"]
    pub pdelay: int32,
    #[doc = " next DC slave"]
    pub DCnext: uint16,
    #[doc = " previous DC slave"]
    pub DCprevious: uint16,
    #[doc = " DC cycle time in ns"]
    pub DCcycle: int32,
    #[doc = " DC shift from clock modulus boundary"]
    pub DCshift: int32,
    #[doc = " DC sync activation, 0=off, 1=on"]
    pub DCactive: uint8,
    #[doc = " link to config table"]
    pub configindex: uint16,
    #[doc = " link to SII config"]
    pub SIIindex: uint16,
    #[doc = " 1 = 8 bytes per read, 0 = 4 bytes per read"]
    pub eep_8byte: uint8,
    #[doc = " 0 = eeprom to master , 1 = eeprom to PDI"]
    pub eep_pdi: uint8,
    #[doc = " CoE details"]
    pub CoEdetails: uint8,
    #[doc = " FoE details"]
    pub FoEdetails: uint8,
    #[doc = " EoE details"]
    pub EoEdetails: uint8,
    #[doc = " SoE details"]
    pub SoEdetails: uint8,
    #[doc = " E-bus current"]
    pub Ebuscurrent: int16,
    #[doc = " if >0 block use of LRW in processdata"]
    pub blockLRW: uint8,
    #[doc = " group"]
    pub group: uint8,
    #[doc = " first unused FMMU"]
    pub FMMUunused: uint8,
    #[doc = " Boolean for tracking whether the slave is (not) responding, not used/set by the SOEM library"]
    pub islost: boolean,
    #[doc = " registered configuration function PO->SO, (DEPRECATED)"]
    pub PO2SOconfig:
        ::std::option::Option<unsafe extern "C" fn(slave: uint16) -> ::std::os::raw::c_int>,
    #[doc = " registered configuration function PO->SO"]
    pub PO2SOconfigx: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ecx_contextt, slave: uint16) -> ::std::os::raw::c_int,
    >,
    #[doc = " readable name"]
    pub name: [::std::os::raw::c_char; 41usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_slave"][::std::mem::size_of::<ec_slave>() - 344usize];
    ["Alignment of ec_slave"][::std::mem::align_of::<ec_slave>() - 8usize];
    ["Offset of field: ec_slave::state"][::std::mem::offset_of!(ec_slave, state) - 0usize];
    ["Offset of field: ec_slave::ALstatuscode"]
        [::std::mem::offset_of!(ec_slave, ALstatuscode) - 2usize];
    ["Offset of field: ec_slave::configadr"][::std::mem::offset_of!(ec_slave, configadr) - 4usize];
    ["Offset of field: ec_slave::aliasadr"][::std::mem::offset_of!(ec_slave, aliasadr) - 6usize];
    ["Offset of field: ec_slave::eep_man"][::std::mem::offset_of!(ec_slave, eep_man) - 8usize];
    ["Offset of field: ec_slave::eep_id"][::std::mem::offset_of!(ec_slave, eep_id) - 12usize];
    ["Offset of field: ec_slave::eep_rev"][::std::mem::offset_of!(ec_slave, eep_rev) - 16usize];
    ["Offset of field: ec_slave::eep_sn"][::std::mem::offset_of!(ec_slave, eep_sn) - 20usize];
    ["Offset of field: ec_slave::Itype"][::std::mem::offset_of!(ec_slave, Itype) - 24usize];
    ["Offset of field: ec_slave::Dtype"][::std::mem::offset_of!(ec_slave, Dtype) - 26usize];
    ["Offset of field: ec_slave::Obits"][::std::mem::offset_of!(ec_slave, Obits) - 28usize];
    ["Offset of field: ec_slave::Obytes"][::std::mem::offset_of!(ec_slave, Obytes) - 32usize];
    ["Offset of field: ec_slave::outputs"][::std::mem::offset_of!(ec_slave, outputs) - 40usize];
    ["Offset of field: ec_slave::Ostartbit"][::std::mem::offset_of!(ec_slave, Ostartbit) - 48usize];
    ["Offset of field: ec_slave::Ibits"][::std::mem::offset_of!(ec_slave, Ibits) - 50usize];
    ["Offset of field: ec_slave::Ibytes"][::std::mem::offset_of!(ec_slave, Ibytes) - 52usize];
    ["Offset of field: ec_slave::inputs"][::std::mem::offset_of!(ec_slave, inputs) - 56usize];
    ["Offset of field: ec_slave::Istartbit"][::std::mem::offset_of!(ec_slave, Istartbit) - 64usize];
    ["Offset of field: ec_slave::SM"][::std::mem::offset_of!(ec_slave, SM) - 65usize];
    ["Offset of field: ec_slave::SMtype"][::std::mem::offset_of!(ec_slave, SMtype) - 129usize];
    ["Offset of field: ec_slave::FMMU"][::std::mem::offset_of!(ec_slave, FMMU) - 137usize];
    ["Offset of field: ec_slave::FMMU0func"]
        [::std::mem::offset_of!(ec_slave, FMMU0func) - 201usize];
    ["Offset of field: ec_slave::FMMU1func"]
        [::std::mem::offset_of!(ec_slave, FMMU1func) - 202usize];
    ["Offset of field: ec_slave::FMMU2func"]
        [::std::mem::offset_of!(ec_slave, FMMU2func) - 203usize];
    ["Offset of field: ec_slave::FMMU3func"]
        [::std::mem::offset_of!(ec_slave, FMMU3func) - 204usize];
    ["Offset of field: ec_slave::mbx_l"][::std::mem::offset_of!(ec_slave, mbx_l) - 206usize];
    ["Offset of field: ec_slave::mbx_wo"][::std::mem::offset_of!(ec_slave, mbx_wo) - 208usize];
    ["Offset of field: ec_slave::mbx_rl"][::std::mem::offset_of!(ec_slave, mbx_rl) - 210usize];
    ["Offset of field: ec_slave::mbx_ro"][::std::mem::offset_of!(ec_slave, mbx_ro) - 212usize];
    ["Offset of field: ec_slave::mbx_proto"]
        [::std::mem::offset_of!(ec_slave, mbx_proto) - 214usize];
    ["Offset of field: ec_slave::mbx_cnt"][::std::mem::offset_of!(ec_slave, mbx_cnt) - 216usize];
    ["Offset of field: ec_slave::hasdc"][::std::mem::offset_of!(ec_slave, hasdc) - 217usize];
    ["Offset of field: ec_slave::ptype"][::std::mem::offset_of!(ec_slave, ptype) - 218usize];
    ["Offset of field: ec_slave::topology"][::std::mem::offset_of!(ec_slave, topology) - 219usize];
    ["Offset of field: ec_slave::activeports"]
        [::std::mem::offset_of!(ec_slave, activeports) - 220usize];
    ["Offset of field: ec_slave::consumedports"]
        [::std::mem::offset_of!(ec_slave, consumedports) - 221usize];
    ["Offset of field: ec_slave::parent"][::std::mem::offset_of!(ec_slave, parent) - 222usize];
    ["Offset of field: ec_slave::parentport"]
        [::std::mem::offset_of!(ec_slave, parentport) - 224usize];
    ["Offset of field: ec_slave::entryport"]
        [::std::mem::offset_of!(ec_slave, entryport) - 225usize];
    ["Offset of field: ec_slave::DCrtA"][::std::mem::offset_of!(ec_slave, DCrtA) - 228usize];
    ["Offset of field: ec_slave::DCrtB"][::std::mem::offset_of!(ec_slave, DCrtB) - 232usize];
    ["Offset of field: ec_slave::DCrtC"][::std::mem::offset_of!(ec_slave, DCrtC) - 236usize];
    ["Offset of field: ec_slave::DCrtD"][::std::mem::offset_of!(ec_slave, DCrtD) - 240usize];
    ["Offset of field: ec_slave::pdelay"][::std::mem::offset_of!(ec_slave, pdelay) - 244usize];
    ["Offset of field: ec_slave::DCnext"][::std::mem::offset_of!(ec_slave, DCnext) - 248usize];
    ["Offset of field: ec_slave::DCprevious"]
        [::std::mem::offset_of!(ec_slave, DCprevious) - 250usize];
    ["Offset of field: ec_slave::DCcycle"][::std::mem::offset_of!(ec_slave, DCcycle) - 252usize];
    ["Offset of field: ec_slave::DCshift"][::std::mem::offset_of!(ec_slave, DCshift) - 256usize];
    ["Offset of field: ec_slave::DCactive"][::std::mem::offset_of!(ec_slave, DCactive) - 260usize];
    ["Offset of field: ec_slave::configindex"]
        [::std::mem::offset_of!(ec_slave, configindex) - 262usize];
    ["Offset of field: ec_slave::SIIindex"][::std::mem::offset_of!(ec_slave, SIIindex) - 264usize];
    ["Offset of field: ec_slave::eep_8byte"]
        [::std::mem::offset_of!(ec_slave, eep_8byte) - 266usize];
    ["Offset of field: ec_slave::eep_pdi"][::std::mem::offset_of!(ec_slave, eep_pdi) - 267usize];
    ["Offset of field: ec_slave::CoEdetails"]
        [::std::mem::offset_of!(ec_slave, CoEdetails) - 268usize];
    ["Offset of field: ec_slave::FoEdetails"]
        [::std::mem::offset_of!(ec_slave, FoEdetails) - 269usize];
    ["Offset of field: ec_slave::EoEdetails"]
        [::std::mem::offset_of!(ec_slave, EoEdetails) - 270usize];
    ["Offset of field: ec_slave::SoEdetails"]
        [::std::mem::offset_of!(ec_slave, SoEdetails) - 271usize];
    ["Offset of field: ec_slave::Ebuscurrent"]
        [::std::mem::offset_of!(ec_slave, Ebuscurrent) - 272usize];
    ["Offset of field: ec_slave::blockLRW"][::std::mem::offset_of!(ec_slave, blockLRW) - 274usize];
    ["Offset of field: ec_slave::group"][::std::mem::offset_of!(ec_slave, group) - 275usize];
    ["Offset of field: ec_slave::FMMUunused"]
        [::std::mem::offset_of!(ec_slave, FMMUunused) - 276usize];
    ["Offset of field: ec_slave::islost"][::std::mem::offset_of!(ec_slave, islost) - 277usize];
    ["Offset of field: ec_slave::PO2SOconfig"]
        [::std::mem::offset_of!(ec_slave, PO2SOconfig) - 280usize];
    ["Offset of field: ec_slave::PO2SOconfigx"]
        [::std::mem::offset_of!(ec_slave, PO2SOconfigx) - 288usize];
    ["Offset of field: ec_slave::name"][::std::mem::offset_of!(ec_slave, name) - 296usize];
};
#[doc = " for list of ethercat slaves detected"]
pub type ec_slavet = ec_slave;
#[doc = " for list of ethercat slave groups"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_group {
    #[doc = " logical start address for this group"]
    pub logstartaddr: uint32,
    #[doc = " output bytes, if Obits < 8 then Obytes = 0"]
    pub Obytes: uint32,
    #[doc = " output pointer in IOmap buffer"]
    pub outputs: *mut uint8,
    #[doc = " input bytes, if Ibits < 8 then Ibytes = 0"]
    pub Ibytes: uint32,
    #[doc = " input pointer in IOmap buffer"]
    pub inputs: *mut uint8,
    #[doc = " has DC capabillity"]
    pub hasdc: boolean,
    #[doc = " next DC slave"]
    pub DCnext: uint16,
    #[doc = " E-bus current"]
    pub Ebuscurrent: int16,
    #[doc = " if >0 block use of LRW in processdata"]
    pub blockLRW: uint8,
    #[doc = " IO segments used"]
    pub nsegments: uint16,
    #[doc = " 1st input segment"]
    pub Isegment: uint16,
    #[doc = " Offset in input segment"]
    pub Ioffset: uint16,
    #[doc = " Expected workcounter outputs"]
    pub outputsWKC: uint16,
    #[doc = " Expected workcounter inputs"]
    pub inputsWKC: uint16,
    #[doc = " check slave states"]
    pub docheckstate: boolean,
    #[doc = " IO segmentation list. Datagrams must not break SM in two."]
    pub IOsegment: [uint32; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_group"][::std::mem::size_of::<ec_group>() - 312usize];
    ["Alignment of ec_group"][::std::mem::align_of::<ec_group>() - 8usize];
    ["Offset of field: ec_group::logstartaddr"]
        [::std::mem::offset_of!(ec_group, logstartaddr) - 0usize];
    ["Offset of field: ec_group::Obytes"][::std::mem::offset_of!(ec_group, Obytes) - 4usize];
    ["Offset of field: ec_group::outputs"][::std::mem::offset_of!(ec_group, outputs) - 8usize];
    ["Offset of field: ec_group::Ibytes"][::std::mem::offset_of!(ec_group, Ibytes) - 16usize];
    ["Offset of field: ec_group::inputs"][::std::mem::offset_of!(ec_group, inputs) - 24usize];
    ["Offset of field: ec_group::hasdc"][::std::mem::offset_of!(ec_group, hasdc) - 32usize];
    ["Offset of field: ec_group::DCnext"][::std::mem::offset_of!(ec_group, DCnext) - 34usize];
    ["Offset of field: ec_group::Ebuscurrent"]
        [::std::mem::offset_of!(ec_group, Ebuscurrent) - 36usize];
    ["Offset of field: ec_group::blockLRW"][::std::mem::offset_of!(ec_group, blockLRW) - 38usize];
    ["Offset of field: ec_group::nsegments"][::std::mem::offset_of!(ec_group, nsegments) - 40usize];
    ["Offset of field: ec_group::Isegment"][::std::mem::offset_of!(ec_group, Isegment) - 42usize];
    ["Offset of field: ec_group::Ioffset"][::std::mem::offset_of!(ec_group, Ioffset) - 44usize];
    ["Offset of field: ec_group::outputsWKC"]
        [::std::mem::offset_of!(ec_group, outputsWKC) - 46usize];
    ["Offset of field: ec_group::inputsWKC"][::std::mem::offset_of!(ec_group, inputsWKC) - 48usize];
    ["Offset of field: ec_group::docheckstate"]
        [::std::mem::offset_of!(ec_group, docheckstate) - 50usize];
    ["Offset of field: ec_group::IOsegment"][::std::mem::offset_of!(ec_group, IOsegment) - 52usize];
};
#[doc = " for list of ethercat slave groups"]
pub type ec_groupt = ec_group;
#[doc = " SII FMMU structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_eepromFMMU {
    pub Startpos: uint16,
    pub nFMMU: uint8,
    pub FMMU0: uint8,
    pub FMMU1: uint8,
    pub FMMU2: uint8,
    pub FMMU3: uint8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_eepromFMMU"][::std::mem::size_of::<ec_eepromFMMU>() - 8usize];
    ["Alignment of ec_eepromFMMU"][::std::mem::align_of::<ec_eepromFMMU>() - 2usize];
    ["Offset of field: ec_eepromFMMU::Startpos"]
        [::std::mem::offset_of!(ec_eepromFMMU, Startpos) - 0usize];
    ["Offset of field: ec_eepromFMMU::nFMMU"]
        [::std::mem::offset_of!(ec_eepromFMMU, nFMMU) - 2usize];
    ["Offset of field: ec_eepromFMMU::FMMU0"]
        [::std::mem::offset_of!(ec_eepromFMMU, FMMU0) - 3usize];
    ["Offset of field: ec_eepromFMMU::FMMU1"]
        [::std::mem::offset_of!(ec_eepromFMMU, FMMU1) - 4usize];
    ["Offset of field: ec_eepromFMMU::FMMU2"]
        [::std::mem::offset_of!(ec_eepromFMMU, FMMU2) - 5usize];
    ["Offset of field: ec_eepromFMMU::FMMU3"]
        [::std::mem::offset_of!(ec_eepromFMMU, FMMU3) - 6usize];
};
#[doc = " SII FMMU structure"]
pub type ec_eepromFMMUt = ec_eepromFMMU;
#[doc = " SII SM structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_eepromSM {
    pub Startpos: uint16,
    pub nSM: uint8,
    pub PhStart: uint16,
    pub Plength: uint16,
    pub Creg: uint8,
    pub Sreg: uint8,
    pub Activate: uint8,
    pub PDIctrl: uint8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_eepromSM"][::std::mem::size_of::<ec_eepromSM>() - 12usize];
    ["Alignment of ec_eepromSM"][::std::mem::align_of::<ec_eepromSM>() - 2usize];
    ["Offset of field: ec_eepromSM::Startpos"]
        [::std::mem::offset_of!(ec_eepromSM, Startpos) - 0usize];
    ["Offset of field: ec_eepromSM::nSM"][::std::mem::offset_of!(ec_eepromSM, nSM) - 2usize];
    ["Offset of field: ec_eepromSM::PhStart"]
        [::std::mem::offset_of!(ec_eepromSM, PhStart) - 4usize];
    ["Offset of field: ec_eepromSM::Plength"]
        [::std::mem::offset_of!(ec_eepromSM, Plength) - 6usize];
    ["Offset of field: ec_eepromSM::Creg"][::std::mem::offset_of!(ec_eepromSM, Creg) - 8usize];
    ["Offset of field: ec_eepromSM::Sreg"][::std::mem::offset_of!(ec_eepromSM, Sreg) - 9usize];
    ["Offset of field: ec_eepromSM::Activate"]
        [::std::mem::offset_of!(ec_eepromSM, Activate) - 10usize];
    ["Offset of field: ec_eepromSM::PDIctrl"]
        [::std::mem::offset_of!(ec_eepromSM, PDIctrl) - 11usize];
};
#[doc = " SII SM structure"]
pub type ec_eepromSMt = ec_eepromSM;
#[doc = " record to store rxPDO and txPDO table from eeprom"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_eepromPDO {
    pub Startpos: uint16,
    pub Length: uint16,
    pub nPDO: uint16,
    pub Index: [uint16; 512usize],
    pub SyncM: [uint16; 512usize],
    pub BitSize: [uint16; 512usize],
    pub SMbitsize: [uint16; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_eepromPDO"][::std::mem::size_of::<ec_eepromPDO>() - 3094usize];
    ["Alignment of ec_eepromPDO"][::std::mem::align_of::<ec_eepromPDO>() - 2usize];
    ["Offset of field: ec_eepromPDO::Startpos"]
        [::std::mem::offset_of!(ec_eepromPDO, Startpos) - 0usize];
    ["Offset of field: ec_eepromPDO::Length"]
        [::std::mem::offset_of!(ec_eepromPDO, Length) - 2usize];
    ["Offset of field: ec_eepromPDO::nPDO"][::std::mem::offset_of!(ec_eepromPDO, nPDO) - 4usize];
    ["Offset of field: ec_eepromPDO::Index"][::std::mem::offset_of!(ec_eepromPDO, Index) - 6usize];
    ["Offset of field: ec_eepromPDO::SyncM"]
        [::std::mem::offset_of!(ec_eepromPDO, SyncM) - 1030usize];
    ["Offset of field: ec_eepromPDO::BitSize"]
        [::std::mem::offset_of!(ec_eepromPDO, BitSize) - 2054usize];
    ["Offset of field: ec_eepromPDO::SMbitsize"]
        [::std::mem::offset_of!(ec_eepromPDO, SMbitsize) - 3078usize];
};
#[doc = " record to store rxPDO and txPDO table from eeprom"]
pub type ec_eepromPDOt = ec_eepromPDO;
#[doc = " mailbox buffer array"]
pub type ec_mbxbuft = [uint8; 1487usize];
#[doc = " standard ethercat mailbox header"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ec_mbxheader {
    pub length: uint16,
    pub address: uint16,
    pub priority: uint8,
    pub mbxtype: uint8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_mbxheader"][::std::mem::size_of::<ec_mbxheader>() - 6usize];
    ["Alignment of ec_mbxheader"][::std::mem::align_of::<ec_mbxheader>() - 1usize];
    ["Offset of field: ec_mbxheader::length"]
        [::std::mem::offset_of!(ec_mbxheader, length) - 0usize];
    ["Offset of field: ec_mbxheader::address"]
        [::std::mem::offset_of!(ec_mbxheader, address) - 2usize];
    ["Offset of field: ec_mbxheader::priority"]
        [::std::mem::offset_of!(ec_mbxheader, priority) - 4usize];
    ["Offset of field: ec_mbxheader::mbxtype"]
        [::std::mem::offset_of!(ec_mbxheader, mbxtype) - 5usize];
};
#[doc = " standard ethercat mailbox header"]
pub type ec_mbxheadert = ec_mbxheader;
#[doc = " ALstatus and ALstatus code"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ec_alstatus {
    pub alstatus: uint16,
    pub unused: uint16,
    pub alstatuscode: uint16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_alstatus"][::std::mem::size_of::<ec_alstatus>() - 6usize];
    ["Alignment of ec_alstatus"][::std::mem::align_of::<ec_alstatus>() - 1usize];
    ["Offset of field: ec_alstatus::alstatus"]
        [::std::mem::offset_of!(ec_alstatus, alstatus) - 0usize];
    ["Offset of field: ec_alstatus::unused"][::std::mem::offset_of!(ec_alstatus, unused) - 2usize];
    ["Offset of field: ec_alstatus::alstatuscode"]
        [::std::mem::offset_of!(ec_alstatus, alstatuscode) - 4usize];
};
#[doc = " ALstatus and ALstatus code"]
pub type ec_alstatust = ec_alstatus;
#[doc = " stack structure to store segmented LRD/LWR/LRW constructs"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_idxstack {
    pub pushed: uint8,
    pub pulled: uint8,
    pub idx: [uint8; 16usize],
    pub data: [*mut ::std::os::raw::c_void; 16usize],
    pub length: [uint16; 16usize],
    pub dcoffset: [uint16; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_idxstack"][::std::mem::size_of::<ec_idxstack>() - 216usize];
    ["Alignment of ec_idxstack"][::std::mem::align_of::<ec_idxstack>() - 8usize];
    ["Offset of field: ec_idxstack::pushed"][::std::mem::offset_of!(ec_idxstack, pushed) - 0usize];
    ["Offset of field: ec_idxstack::pulled"][::std::mem::offset_of!(ec_idxstack, pulled) - 1usize];
    ["Offset of field: ec_idxstack::idx"][::std::mem::offset_of!(ec_idxstack, idx) - 2usize];
    ["Offset of field: ec_idxstack::data"][::std::mem::offset_of!(ec_idxstack, data) - 24usize];
    ["Offset of field: ec_idxstack::length"]
        [::std::mem::offset_of!(ec_idxstack, length) - 152usize];
    ["Offset of field: ec_idxstack::dcoffset"]
        [::std::mem::offset_of!(ec_idxstack, dcoffset) - 184usize];
};
#[doc = " stack structure to store segmented LRD/LWR/LRW constructs"]
pub type ec_idxstackT = ec_idxstack;
#[doc = " ringbuf for error storage"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ec_ering {
    pub head: int16,
    pub tail: int16,
    pub Error: [ec_errort; 65usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_ering"][::std::mem::size_of::<ec_ering>() - 1824usize];
    ["Alignment of ec_ering"][::std::mem::align_of::<ec_ering>() - 4usize];
    ["Offset of field: ec_ering::head"][::std::mem::offset_of!(ec_ering, head) - 0usize];
    ["Offset of field: ec_ering::tail"][::std::mem::offset_of!(ec_ering, tail) - 2usize];
    ["Offset of field: ec_ering::Error"][::std::mem::offset_of!(ec_ering, Error) - 4usize];
};
#[doc = " ringbuf for error storage"]
pub type ec_eringt = ec_ering;
#[doc = " SyncManager Communication Type structure for CA"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ec_SMcommtype {
    pub n: uint8,
    pub nu1: uint8,
    pub SMtype: [uint8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_SMcommtype"][::std::mem::size_of::<ec_SMcommtype>() - 10usize];
    ["Alignment of ec_SMcommtype"][::std::mem::align_of::<ec_SMcommtype>() - 1usize];
    ["Offset of field: ec_SMcommtype::n"][::std::mem::offset_of!(ec_SMcommtype, n) - 0usize];
    ["Offset of field: ec_SMcommtype::nu1"][::std::mem::offset_of!(ec_SMcommtype, nu1) - 1usize];
    ["Offset of field: ec_SMcommtype::SMtype"]
        [::std::mem::offset_of!(ec_SMcommtype, SMtype) - 2usize];
};
#[doc = " SyncManager Communication Type structure for CA"]
pub type ec_SMcommtypet = ec_SMcommtype;
#[doc = " SDO assign structure for CA"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ec_PDOassign {
    pub n: uint8,
    pub nu1: uint8,
    pub index: [uint16; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_PDOassign"][::std::mem::size_of::<ec_PDOassign>() - 514usize];
    ["Alignment of ec_PDOassign"][::std::mem::align_of::<ec_PDOassign>() - 1usize];
    ["Offset of field: ec_PDOassign::n"][::std::mem::offset_of!(ec_PDOassign, n) - 0usize];
    ["Offset of field: ec_PDOassign::nu1"][::std::mem::offset_of!(ec_PDOassign, nu1) - 1usize];
    ["Offset of field: ec_PDOassign::index"][::std::mem::offset_of!(ec_PDOassign, index) - 2usize];
};
#[doc = " SDO assign structure for CA"]
pub type ec_PDOassignt = ec_PDOassign;
#[doc = " SDO description structure for CA"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ec_PDOdesc {
    pub n: uint8,
    pub nu1: uint8,
    pub PDO: [uint32; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_PDOdesc"][::std::mem::size_of::<ec_PDOdesc>() - 1026usize];
    ["Alignment of ec_PDOdesc"][::std::mem::align_of::<ec_PDOdesc>() - 1usize];
    ["Offset of field: ec_PDOdesc::n"][::std::mem::offset_of!(ec_PDOdesc, n) - 0usize];
    ["Offset of field: ec_PDOdesc::nu1"][::std::mem::offset_of!(ec_PDOdesc, nu1) - 1usize];
    ["Offset of field: ec_PDOdesc::PDO"][::std::mem::offset_of!(ec_PDOdesc, PDO) - 2usize];
};
#[doc = " SDO description structure for CA"]
pub type ec_PDOdesct = ec_PDOdesc;
#[doc = " Context structure , referenced by all ecx functions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecx_context {
    #[doc = " port reference, may include red_port"]
    pub port: *mut ecx_portt,
    #[doc = " slavelist reference"]
    pub slavelist: *mut ec_slavet,
    #[doc = " number of slaves found in configuration"]
    pub slavecount: *mut ::std::os::raw::c_int,
    #[doc = " maximum number of slaves allowed in slavelist"]
    pub maxslave: ::std::os::raw::c_int,
    #[doc = " grouplist reference"]
    pub grouplist: *mut ec_groupt,
    #[doc = " maximum number of groups allowed in grouplist"]
    pub maxgroup: ::std::os::raw::c_int,
    #[doc = " internal, reference to eeprom cache buffer"]
    pub esibuf: *mut uint8,
    #[doc = " internal, reference to eeprom cache map"]
    pub esimap: *mut uint32,
    #[doc = " internal, current slave for eeprom cache"]
    pub esislave: uint16,
    #[doc = " internal, reference to error list"]
    pub elist: *mut ec_eringt,
    #[doc = " internal, reference to processdata stack buffer info"]
    pub idxstack: *mut ec_idxstackT,
    #[doc = " reference to ecaterror state"]
    pub ecaterror: *mut boolean,
    #[doc = " reference to last DC time from slaves"]
    pub DCtime: *mut int64,
    #[doc = " internal, SM buffer"]
    pub SMcommtype: *mut ec_SMcommtypet,
    #[doc = " internal, PDO assign list"]
    pub PDOassign: *mut ec_PDOassignt,
    #[doc = " internal, PDO description list"]
    pub PDOdesc: *mut ec_PDOdesct,
    #[doc = " internal, SM list from eeprom"]
    pub eepSM: *mut ec_eepromSMt,
    #[doc = " internal, FMMU list from eeprom"]
    pub eepFMMU: *mut ec_eepromFMMUt,
    #[doc = " registered FoE hook"]
    pub FOEhook: ::std::option::Option<
        unsafe extern "C" fn(
            slave: uint16,
            packetnumber: ::std::os::raw::c_int,
            datasize: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " registered EoE hook"]
    pub EOEhook: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ecx_contextt,
            slave: uint16,
            eoembx: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " flag to control legacy automatic state change or manual state change"]
    pub manualstatechange: ::std::os::raw::c_int,
    #[doc = " userdata, promotes application configuration esp. in EC_VER2 with multiple\n ec_context instances. Note: userdata memory is managed by application, not SOEM"]
    pub userdata: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecx_context"][::std::mem::size_of::<ecx_context>() - 176usize];
    ["Alignment of ecx_context"][::std::mem::align_of::<ecx_context>() - 8usize];
    ["Offset of field: ecx_context::port"][::std::mem::offset_of!(ecx_context, port) - 0usize];
    ["Offset of field: ecx_context::slavelist"]
        [::std::mem::offset_of!(ecx_context, slavelist) - 8usize];
    ["Offset of field: ecx_context::slavecount"]
        [::std::mem::offset_of!(ecx_context, slavecount) - 16usize];
    ["Offset of field: ecx_context::maxslave"]
        [::std::mem::offset_of!(ecx_context, maxslave) - 24usize];
    ["Offset of field: ecx_context::grouplist"]
        [::std::mem::offset_of!(ecx_context, grouplist) - 32usize];
    ["Offset of field: ecx_context::maxgroup"]
        [::std::mem::offset_of!(ecx_context, maxgroup) - 40usize];
    ["Offset of field: ecx_context::esibuf"][::std::mem::offset_of!(ecx_context, esibuf) - 48usize];
    ["Offset of field: ecx_context::esimap"][::std::mem::offset_of!(ecx_context, esimap) - 56usize];
    ["Offset of field: ecx_context::esislave"]
        [::std::mem::offset_of!(ecx_context, esislave) - 64usize];
    ["Offset of field: ecx_context::elist"][::std::mem::offset_of!(ecx_context, elist) - 72usize];
    ["Offset of field: ecx_context::idxstack"]
        [::std::mem::offset_of!(ecx_context, idxstack) - 80usize];
    ["Offset of field: ecx_context::ecaterror"]
        [::std::mem::offset_of!(ecx_context, ecaterror) - 88usize];
    ["Offset of field: ecx_context::DCtime"][::std::mem::offset_of!(ecx_context, DCtime) - 96usize];
    ["Offset of field: ecx_context::SMcommtype"]
        [::std::mem::offset_of!(ecx_context, SMcommtype) - 104usize];
    ["Offset of field: ecx_context::PDOassign"]
        [::std::mem::offset_of!(ecx_context, PDOassign) - 112usize];
    ["Offset of field: ecx_context::PDOdesc"]
        [::std::mem::offset_of!(ecx_context, PDOdesc) - 120usize];
    ["Offset of field: ecx_context::eepSM"][::std::mem::offset_of!(ecx_context, eepSM) - 128usize];
    ["Offset of field: ecx_context::eepFMMU"]
        [::std::mem::offset_of!(ecx_context, eepFMMU) - 136usize];
    ["Offset of field: ecx_context::FOEhook"]
        [::std::mem::offset_of!(ecx_context, FOEhook) - 144usize];
    ["Offset of field: ecx_context::EOEhook"]
        [::std::mem::offset_of!(ecx_context, EOEhook) - 152usize];
    ["Offset of field: ecx_context::manualstatechange"]
        [::std::mem::offset_of!(ecx_context, manualstatechange) - 160usize];
    ["Offset of field: ecx_context::userdata"]
        [::std::mem::offset_of!(ecx_context, userdata) - 168usize];
};
unsafe extern "C" {
    #[doc = " global struct to hold default master context"]
    pub static mut ecx_context: ecx_contextt;
}
unsafe extern "C" {
    #[doc = " main slave data structure array"]
    pub static mut ec_slave: [ec_slavet; 200usize];
}
unsafe extern "C" {
    #[doc = " number of slaves found by configuration function"]
    pub static mut ec_slavecount: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " slave group structure"]
    pub static mut ec_group: [ec_groupt; 2usize];
}
unsafe extern "C" {
    pub static mut EcatError: boolean;
}
unsafe extern "C" {
    pub static mut ec_DCtime: int64;
}
unsafe extern "C" {
    pub fn ec_pusherror(Ec: *const ec_errort);
}
unsafe extern "C" {
    pub fn ec_poperror(Ec: *mut ec_errort) -> boolean;
}
unsafe extern "C" {
    pub fn ec_iserror() -> boolean;
}
unsafe extern "C" {
    pub fn ec_packeterror(Slave: uint16, Index: uint16, SubIdx: uint8, ErrorCode: uint16);
}
unsafe extern "C" {
    pub fn ec_init(ifname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_init_redundant(
        ifname: *const ::std::os::raw::c_char,
        if2name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_close();
}
unsafe extern "C" {
    pub fn ec_siigetbyte(slave: uint16, address: uint16) -> uint8;
}
unsafe extern "C" {
    pub fn ec_siifind(slave: uint16, cat: uint16) -> int16;
}
unsafe extern "C" {
    pub fn ec_siistring(str_: *mut ::std::os::raw::c_char, slave: uint16, Sn: uint16);
}
unsafe extern "C" {
    pub fn ec_siiFMMU(slave: uint16, FMMU: *mut ec_eepromFMMUt) -> uint16;
}
unsafe extern "C" {
    pub fn ec_siiSM(slave: uint16, SM: *mut ec_eepromSMt) -> uint16;
}
unsafe extern "C" {
    pub fn ec_siiSMnext(slave: uint16, SM: *mut ec_eepromSMt, n: uint16) -> uint16;
}
unsafe extern "C" {
    pub fn ec_siiPDO(slave: uint16, PDO: *mut ec_eepromPDOt, t: uint8) -> uint32;
}
unsafe extern "C" {
    pub fn ec_readstate() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_writestate(slave: uint16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_statecheck(slave: uint16, reqstate: uint16, timeout: ::std::os::raw::c_int)
    -> uint16;
}
unsafe extern "C" {
    pub fn ec_mbxempty(slave: uint16, timeout: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_mbxsend(
        slave: uint16,
        mbx: *mut ec_mbxbuft,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_mbxreceive(
        slave: uint16,
        mbx: *mut ec_mbxbuft,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_esidump(slave: uint16, esibuf: *mut uint8);
}
unsafe extern "C" {
    pub fn ec_readeeprom(slave: uint16, eeproma: uint16, timeout: ::std::os::raw::c_int) -> uint32;
}
unsafe extern "C" {
    pub fn ec_writeeeprom(
        slave: uint16,
        eeproma: uint16,
        data: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_eeprom2master(slave: uint16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_eeprom2pdi(slave: uint16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_readeepromAP(
        aiadr: uint16,
        eeproma: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> uint64;
}
unsafe extern "C" {
    pub fn ec_writeeepromAP(
        aiadr: uint16,
        eeproma: uint16,
        data: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_readeepromFP(
        configadr: uint16,
        eeproma: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> uint64;
}
unsafe extern "C" {
    pub fn ec_writeeepromFP(
        configadr: uint16,
        eeproma: uint16,
        data: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_readeeprom1(slave: uint16, eeproma: uint16);
}
unsafe extern "C" {
    pub fn ec_readeeprom2(slave: uint16, timeout: ::std::os::raw::c_int) -> uint32;
}
unsafe extern "C" {
    pub fn ec_send_processdata_group(group: uint8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_send_overlap_processdata_group(group: uint8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_receive_processdata_group(
        group: uint8,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_send_processdata() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_send_overlap_processdata() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_receive_processdata(timeout: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_find_adapters() -> *mut ec_adaptert;
}
unsafe extern "C" {
    pub fn ec_free_adapters(adapter: *mut ec_adaptert);
}
unsafe extern "C" {
    pub fn ec_nextmbxcnt(cnt: uint8) -> uint8;
}
unsafe extern "C" {
    pub fn ec_clearmbx(Mbx: *mut ec_mbxbuft);
}
unsafe extern "C" {
    pub fn ecx_pusherror(context: *mut ecx_contextt, Ec: *const ec_errort);
}
unsafe extern "C" {
    pub fn ecx_poperror(context: *mut ecx_contextt, Ec: *mut ec_errort) -> boolean;
}
unsafe extern "C" {
    pub fn ecx_iserror(context: *mut ecx_contextt) -> boolean;
}
unsafe extern "C" {
    pub fn ecx_packeterror(
        context: *mut ecx_contextt,
        Slave: uint16,
        Index: uint16,
        SubIdx: uint8,
        ErrorCode: uint16,
    );
}
unsafe extern "C" {
    pub fn ecx_init(
        context: *mut ecx_contextt,
        ifname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_init_redundant(
        context: *mut ecx_contextt,
        redport: *mut ecx_redportt,
        ifname: *const ::std::os::raw::c_char,
        if2name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_close(context: *mut ecx_contextt);
}
unsafe extern "C" {
    pub fn ecx_siigetbyte(context: *mut ecx_contextt, slave: uint16, address: uint16) -> uint8;
}
unsafe extern "C" {
    pub fn ecx_siifind(context: *mut ecx_contextt, slave: uint16, cat: uint16) -> int16;
}
unsafe extern "C" {
    pub fn ecx_siistring(
        context: *mut ecx_contextt,
        str_: *mut ::std::os::raw::c_char,
        slave: uint16,
        Sn: uint16,
    );
}
unsafe extern "C" {
    pub fn ecx_siiFMMU(
        context: *mut ecx_contextt,
        slave: uint16,
        FMMU: *mut ec_eepromFMMUt,
    ) -> uint16;
}
unsafe extern "C" {
    pub fn ecx_siiSM(context: *mut ecx_contextt, slave: uint16, SM: *mut ec_eepromSMt) -> uint16;
}
unsafe extern "C" {
    pub fn ecx_siiSMnext(
        context: *mut ecx_contextt,
        slave: uint16,
        SM: *mut ec_eepromSMt,
        n: uint16,
    ) -> uint16;
}
unsafe extern "C" {
    pub fn ecx_siiPDO(
        context: *mut ecx_contextt,
        slave: uint16,
        PDO: *mut ec_eepromPDOt,
        t: uint8,
    ) -> uint32;
}
unsafe extern "C" {
    pub fn ecx_readstate(context: *mut ecx_contextt) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_writestate(context: *mut ecx_contextt, slave: uint16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_statecheck(
        context: *mut ecx_contextt,
        slave: uint16,
        reqstate: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> uint16;
}
unsafe extern "C" {
    pub fn ecx_mbxempty(
        context: *mut ecx_contextt,
        slave: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_mbxsend(
        context: *mut ecx_contextt,
        slave: uint16,
        mbx: *mut ec_mbxbuft,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_mbxreceive(
        context: *mut ecx_contextt,
        slave: uint16,
        mbx: *mut ec_mbxbuft,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_esidump(context: *mut ecx_contextt, slave: uint16, esibuf: *mut uint8);
}
unsafe extern "C" {
    pub fn ecx_readeeprom(
        context: *mut ecx_contextt,
        slave: uint16,
        eeproma: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> uint32;
}
unsafe extern "C" {
    pub fn ecx_writeeeprom(
        context: *mut ecx_contextt,
        slave: uint16,
        eeproma: uint16,
        data: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_eeprom2master(context: *mut ecx_contextt, slave: uint16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_eeprom2pdi(context: *mut ecx_contextt, slave: uint16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_readeepromAP(
        context: *mut ecx_contextt,
        aiadr: uint16,
        eeproma: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> uint64;
}
unsafe extern "C" {
    pub fn ecx_writeeepromAP(
        context: *mut ecx_contextt,
        aiadr: uint16,
        eeproma: uint16,
        data: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_readeepromFP(
        context: *mut ecx_contextt,
        configadr: uint16,
        eeproma: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> uint64;
}
unsafe extern "C" {
    pub fn ecx_writeeepromFP(
        context: *mut ecx_contextt,
        configadr: uint16,
        eeproma: uint16,
        data: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_readeeprom1(context: *mut ecx_contextt, slave: uint16, eeproma: uint16);
}
unsafe extern "C" {
    pub fn ecx_readeeprom2(
        context: *mut ecx_contextt,
        slave: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> uint32;
}
unsafe extern "C" {
    pub fn ecx_send_overlap_processdata_group(
        context: *mut ecx_contextt,
        group: uint8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_receive_processdata_group(
        context: *mut ecx_contextt,
        group: uint8,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_send_processdata(context: *mut ecx_contextt) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_send_overlap_processdata(context: *mut ecx_contextt) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_receive_processdata(
        context: *mut ecx_contextt,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_send_processdata_group(
        context: *mut ecx_contextt,
        group: uint8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_configdc() -> boolean;
}
unsafe extern "C" {
    pub fn ec_dcsync0(slave: uint16, act: boolean, CyclTime: uint32, CyclShift: int32);
}
unsafe extern "C" {
    pub fn ec_dcsync01(
        slave: uint16,
        act: boolean,
        CyclTime0: uint32,
        CyclTime1: uint32,
        CyclShift: int32,
    );
}
unsafe extern "C" {
    pub fn ecx_configdc(context: *mut ecx_contextt) -> boolean;
}
unsafe extern "C" {
    pub fn ecx_dcsync0(
        context: *mut ecx_contextt,
        slave: uint16,
        act: boolean,
        CyclTime: uint32,
        CyclShift: int32,
    );
}
unsafe extern "C" {
    pub fn ecx_dcsync01(
        context: *mut ecx_contextt,
        slave: uint16,
        act: boolean,
        CyclTime0: uint32,
        CyclTime1: uint32,
        CyclShift: int32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_ODlistt {
    #[doc = " slave number"]
    pub Slave: uint16,
    #[doc = " number of entries in list"]
    pub Entries: uint16,
    #[doc = " array of indexes"]
    pub Index: [uint16; 1024usize],
    #[doc = " array of datatypes, see EtherCAT specification"]
    pub DataType: [uint16; 1024usize],
    #[doc = " array of object codes, see EtherCAT specification"]
    pub ObjectCode: [uint8; 1024usize],
    #[doc = " number of subindexes for each index"]
    pub MaxSub: [uint8; 1024usize],
    #[doc = " textual description of each index"]
    pub Name: [[::std::os::raw::c_char; 41usize]; 1024usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_ODlistt"][::std::mem::size_of::<ec_ODlistt>() - 48132usize];
    ["Alignment of ec_ODlistt"][::std::mem::align_of::<ec_ODlistt>() - 2usize];
    ["Offset of field: ec_ODlistt::Slave"][::std::mem::offset_of!(ec_ODlistt, Slave) - 0usize];
    ["Offset of field: ec_ODlistt::Entries"][::std::mem::offset_of!(ec_ODlistt, Entries) - 2usize];
    ["Offset of field: ec_ODlistt::Index"][::std::mem::offset_of!(ec_ODlistt, Index) - 4usize];
    ["Offset of field: ec_ODlistt::DataType"]
        [::std::mem::offset_of!(ec_ODlistt, DataType) - 2052usize];
    ["Offset of field: ec_ODlistt::ObjectCode"]
        [::std::mem::offset_of!(ec_ODlistt, ObjectCode) - 4100usize];
    ["Offset of field: ec_ODlistt::MaxSub"][::std::mem::offset_of!(ec_ODlistt, MaxSub) - 5124usize];
    ["Offset of field: ec_ODlistt::Name"][::std::mem::offset_of!(ec_ODlistt, Name) - 6148usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_OElistt {
    #[doc = " number of entries in list"]
    pub Entries: uint16,
    #[doc = " array of value infos, see EtherCAT specification"]
    pub ValueInfo: [uint8; 256usize],
    #[doc = " array of value infos, see EtherCAT specification"]
    pub DataType: [uint16; 256usize],
    #[doc = " array of bit lengths, see EtherCAT specification"]
    pub BitLength: [uint16; 256usize],
    #[doc = " array of object access bits, see EtherCAT specification"]
    pub ObjAccess: [uint16; 256usize],
    #[doc = " textual description of each index"]
    pub Name: [[::std::os::raw::c_char; 41usize]; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_OElistt"][::std::mem::size_of::<ec_OElistt>() - 12290usize];
    ["Alignment of ec_OElistt"][::std::mem::align_of::<ec_OElistt>() - 2usize];
    ["Offset of field: ec_OElistt::Entries"][::std::mem::offset_of!(ec_OElistt, Entries) - 0usize];
    ["Offset of field: ec_OElistt::ValueInfo"]
        [::std::mem::offset_of!(ec_OElistt, ValueInfo) - 2usize];
    ["Offset of field: ec_OElistt::DataType"]
        [::std::mem::offset_of!(ec_OElistt, DataType) - 258usize];
    ["Offset of field: ec_OElistt::BitLength"]
        [::std::mem::offset_of!(ec_OElistt, BitLength) - 770usize];
    ["Offset of field: ec_OElistt::ObjAccess"]
        [::std::mem::offset_of!(ec_OElistt, ObjAccess) - 1282usize];
    ["Offset of field: ec_OElistt::Name"][::std::mem::offset_of!(ec_OElistt, Name) - 1794usize];
};
unsafe extern "C" {
    pub fn ec_SDOerror(Slave: uint16, Index: uint16, SubIdx: uint8, AbortCode: int32);
}
unsafe extern "C" {
    pub fn ec_SDOread(
        slave: uint16,
        index: uint16,
        subindex: uint8,
        CA: boolean,
        psize: *mut ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_SDOwrite(
        Slave: uint16,
        Index: uint16,
        SubIndex: uint8,
        CA: boolean,
        psize: ::std::os::raw::c_int,
        p: *const ::std::os::raw::c_void,
        Timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_RxPDO(
        Slave: uint16,
        RxPDOnumber: uint16,
        psize: ::std::os::raw::c_int,
        p: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_TxPDO(
        slave: uint16,
        TxPDOnumber: uint16,
        psize: *mut ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_readPDOmap(
        Slave: uint16,
        Osize: *mut uint32,
        Isize: *mut uint32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_readPDOmapCA(
        Slave: uint16,
        Thread_n: ::std::os::raw::c_int,
        Osize: *mut uint32,
        Isize: *mut uint32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_readODlist(Slave: uint16, pODlist: *mut ec_ODlistt) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_readODdescription(Item: uint16, pODlist: *mut ec_ODlistt) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_readOEsingle(
        Item: uint16,
        SubI: uint8,
        pODlist: *mut ec_ODlistt,
        pOElist: *mut ec_OElistt,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_readOE(
        Item: uint16,
        pODlist: *mut ec_ODlistt,
        pOElist: *mut ec_OElistt,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_SDOerror(
        context: *mut ecx_contextt,
        Slave: uint16,
        Index: uint16,
        SubIdx: uint8,
        AbortCode: int32,
    );
}
unsafe extern "C" {
    pub fn ecx_SDOread(
        context: *mut ecx_contextt,
        slave: uint16,
        index: uint16,
        subindex: uint8,
        CA: boolean,
        psize: *mut ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_SDOwrite(
        context: *mut ecx_contextt,
        Slave: uint16,
        Index: uint16,
        SubIndex: uint8,
        CA: boolean,
        psize: ::std::os::raw::c_int,
        p: *const ::std::os::raw::c_void,
        Timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_RxPDO(
        context: *mut ecx_contextt,
        Slave: uint16,
        RxPDOnumber: uint16,
        psize: ::std::os::raw::c_int,
        p: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_TxPDO(
        context: *mut ecx_contextt,
        slave: uint16,
        TxPDOnumber: uint16,
        psize: *mut ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_readPDOmap(
        context: *mut ecx_contextt,
        Slave: uint16,
        Osize: *mut uint32,
        Isize: *mut uint32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_readPDOmapCA(
        context: *mut ecx_contextt,
        Slave: uint16,
        Thread_n: ::std::os::raw::c_int,
        Osize: *mut uint32,
        Isize: *mut uint32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_readODlist(
        context: *mut ecx_contextt,
        Slave: uint16,
        pODlist: *mut ec_ODlistt,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_readODdescription(
        context: *mut ecx_contextt,
        Item: uint16,
        pODlist: *mut ec_ODlistt,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_readOEsingle(
        context: *mut ecx_contextt,
        Item: uint16,
        SubI: uint8,
        pODlist: *mut ec_ODlistt,
        pOElist: *mut ec_OElistt,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_readOE(
        context: *mut ecx_contextt,
        Item: uint16,
        pODlist: *mut ec_ODlistt,
        pOElist: *mut ec_OElistt,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_FOEdefinehook(hook: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_FOEread(
        slave: uint16,
        filename: *mut ::std::os::raw::c_char,
        password: uint32,
        psize: *mut ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_FOEwrite(
        slave: uint16,
        filename: *mut ::std::os::raw::c_char,
        password: uint32,
        psize: ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_FOEdefinehook(
        context: *mut ecx_contextt,
        hook: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_FOEread(
        context: *mut ecx_contextt,
        slave: uint16,
        filename: *mut ::std::os::raw::c_char,
        password: uint32,
        psize: *mut ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_FOEwrite(
        context: *mut ecx_contextt,
        slave: uint16,
        filename: *mut ::std::os::raw::c_char,
        password: uint32,
        psize: ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " SoE name structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ec_SoEnamet {
    #[doc = " current length in bytes of list"]
    pub currentlength: uint16,
    #[doc = " maximum length in bytes of list"]
    pub maxlength: uint16,
    pub name: [::std::os::raw::c_char; 60usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_SoEnamet"][::std::mem::size_of::<ec_SoEnamet>() - 64usize];
    ["Alignment of ec_SoEnamet"][::std::mem::align_of::<ec_SoEnamet>() - 1usize];
    ["Offset of field: ec_SoEnamet::currentlength"]
        [::std::mem::offset_of!(ec_SoEnamet, currentlength) - 0usize];
    ["Offset of field: ec_SoEnamet::maxlength"]
        [::std::mem::offset_of!(ec_SoEnamet, maxlength) - 2usize];
    ["Offset of field: ec_SoEnamet::name"][::std::mem::offset_of!(ec_SoEnamet, name) - 4usize];
};
#[doc = " SoE list structure"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ec_SoElistt {
    #[doc = " current length in bytes of list"]
    pub currentlength: uint16,
    #[doc = " maximum length in bytes of list"]
    pub maxlength: uint16,
    pub __bindgen_anon_1: ec_SoElistt__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ec_SoElistt__bindgen_ty_1 {
    pub byte: [uint8; 8usize],
    pub word: [uint16; 4usize],
    pub dword: [uint32; 2usize],
    pub lword: [uint64; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_SoElistt__bindgen_ty_1"]
        [::std::mem::size_of::<ec_SoElistt__bindgen_ty_1>() - 8usize];
    ["Alignment of ec_SoElistt__bindgen_ty_1"]
        [::std::mem::align_of::<ec_SoElistt__bindgen_ty_1>() - 8usize];
    ["Offset of field: ec_SoElistt__bindgen_ty_1::byte"]
        [::std::mem::offset_of!(ec_SoElistt__bindgen_ty_1, byte) - 0usize];
    ["Offset of field: ec_SoElistt__bindgen_ty_1::word"]
        [::std::mem::offset_of!(ec_SoElistt__bindgen_ty_1, word) - 0usize];
    ["Offset of field: ec_SoElistt__bindgen_ty_1::dword"]
        [::std::mem::offset_of!(ec_SoElistt__bindgen_ty_1, dword) - 0usize];
    ["Offset of field: ec_SoElistt__bindgen_ty_1::lword"]
        [::std::mem::offset_of!(ec_SoElistt__bindgen_ty_1, lword) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_SoElistt"][::std::mem::size_of::<ec_SoElistt>() - 12usize];
    ["Alignment of ec_SoElistt"][::std::mem::align_of::<ec_SoElistt>() - 1usize];
    ["Offset of field: ec_SoElistt::currentlength"]
        [::std::mem::offset_of!(ec_SoElistt, currentlength) - 0usize];
    ["Offset of field: ec_SoElistt::maxlength"]
        [::std::mem::offset_of!(ec_SoElistt, maxlength) - 2usize];
};
#[doc = " SoE IDN mapping structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ec_SoEmappingt {
    #[doc = " current length in bytes of list"]
    pub currentlength: uint16,
    #[doc = " maximum length in bytes of list"]
    pub maxlength: uint16,
    pub idn: [uint16; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_SoEmappingt"][::std::mem::size_of::<ec_SoEmappingt>() - 132usize];
    ["Alignment of ec_SoEmappingt"][::std::mem::align_of::<ec_SoEmappingt>() - 1usize];
    ["Offset of field: ec_SoEmappingt::currentlength"]
        [::std::mem::offset_of!(ec_SoEmappingt, currentlength) - 0usize];
    ["Offset of field: ec_SoEmappingt::maxlength"]
        [::std::mem::offset_of!(ec_SoEmappingt, maxlength) - 2usize];
    ["Offset of field: ec_SoEmappingt::idn"][::std::mem::offset_of!(ec_SoEmappingt, idn) - 4usize];
};
#[doc = " SoE attribute structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ec_SoEattributet {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_SoEattributet"][::std::mem::size_of::<ec_SoEattributet>() - 4usize];
    ["Alignment of ec_SoEattributet"][::std::mem::align_of::<ec_SoEattributet>() - 1usize];
};
impl ec_SoEattributet {
    #[inline]
    pub fn evafactor(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_evafactor(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn evafactor_raw(this: *const Self) -> uint32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_evafactor_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn length(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn length_raw(this: *const Self) -> uint32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_length_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn list(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_list(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn list_raw(this: *const Self) -> uint32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_list_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn command(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_command(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn command_raw(this: *const Self) -> uint32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_command_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn datatype(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_datatype(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn datatype_raw(this: *const Self) -> uint32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_datatype_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved1(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved1_raw(this: *const Self) -> uint32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved1_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn decimals(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_decimals(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn decimals_raw(this: *const Self) -> uint32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_decimals_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wppreop(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wppreop(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wppreop_raw(this: *const Self) -> uint32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wppreop_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wpsafeop(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wpsafeop(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wpsafeop_raw(this: *const Self) -> uint32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wpsafeop_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn wpop(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wpop(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn wpop_raw(this: *const Self) -> uint32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_wpop_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved2(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved2_raw(this: *const Self) -> uint32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved2_raw(this: *mut Self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        evafactor: uint32,
        length: uint32,
        list: uint32,
        command: uint32,
        datatype: uint32,
        reserved1: uint32,
        decimals: uint32,
        wppreop: uint32,
        wpsafeop: uint32,
        wpop: uint32,
        reserved2: uint32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let evafactor: u32 = unsafe { ::std::mem::transmute(evafactor) };
            evafactor as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let list: u32 = unsafe { ::std::mem::transmute(list) };
            list as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let command: u32 = unsafe { ::std::mem::transmute(command) };
            command as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let datatype: u32 = unsafe { ::std::mem::transmute(datatype) };
            datatype as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let decimals: u32 = unsafe { ::std::mem::transmute(decimals) };
            decimals as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let wppreop: u32 = unsafe { ::std::mem::transmute(wppreop) };
            wppreop as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let wpsafeop: u32 = unsafe { ::std::mem::transmute(wpsafeop) };
            wpsafeop as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let wpop: u32 = unsafe { ::std::mem::transmute(wpop) };
            wpop as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub fn ec_SoEread(
        slave: uint16,
        driveNo: uint8,
        elementflags: uint8,
        idn: uint16,
        psize: *mut ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_SoEwrite(
        slave: uint16,
        driveNo: uint8,
        elementflags: uint8,
        idn: uint16,
        psize: ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_readIDNmap(
        slave: uint16,
        Osize: *mut uint32,
        Isize: *mut uint32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_SoEread(
        context: *mut ecx_contextt,
        slave: uint16,
        driveNo: uint8,
        elementflags: uint8,
        idn: uint16,
        psize: *mut ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_SoEwrite(
        context: *mut ecx_contextt,
        slave: uint16,
        driveNo: uint8,
        elementflags: uint8,
        idn: uint16,
        psize: ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_readIDNmap(
        context: *mut ecx_contextt,
        slave: uint16,
        Osize: *mut uint32,
        Isize: *mut uint32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " EOE ip4 address in network order"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eoe_ip4_addr {
    pub addr: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of eoe_ip4_addr"][::std::mem::size_of::<eoe_ip4_addr>() - 4usize];
    ["Alignment of eoe_ip4_addr"][::std::mem::align_of::<eoe_ip4_addr>() - 4usize];
    ["Offset of field: eoe_ip4_addr::addr"][::std::mem::offset_of!(eoe_ip4_addr, addr) - 0usize];
};
#[doc = " EOE ip4 address in network order"]
pub type eoe_ip4_addr_t = eoe_ip4_addr;
#[doc = " EOE ethernet address"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct eoe_ethaddr {
    pub addr: [u8; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of eoe_ethaddr"][::std::mem::size_of::<eoe_ethaddr>() - 6usize];
    ["Alignment of eoe_ethaddr"][::std::mem::align_of::<eoe_ethaddr>() - 1usize];
    ["Offset of field: eoe_ethaddr::addr"][::std::mem::offset_of!(eoe_ethaddr, addr) - 0usize];
};
#[doc = " EOE ethernet address"]
pub type eoe_ethaddr_t = eoe_ethaddr;
#[doc = " EoE IP request structure, storage only, no need to pack"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eoe_param {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub mac: eoe_ethaddr_t,
    pub ip: eoe_ip4_addr_t,
    pub subnet: eoe_ip4_addr_t,
    pub default_gateway: eoe_ip4_addr_t,
    pub dns_ip: eoe_ip4_addr_t,
    pub dns_name: [::std::os::raw::c_char; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of eoe_param"][::std::mem::size_of::<eoe_param>() - 56usize];
    ["Alignment of eoe_param"][::std::mem::align_of::<eoe_param>() - 4usize];
    ["Offset of field: eoe_param::mac"][::std::mem::offset_of!(eoe_param, mac) - 1usize];
    ["Offset of field: eoe_param::ip"][::std::mem::offset_of!(eoe_param, ip) - 8usize];
    ["Offset of field: eoe_param::subnet"][::std::mem::offset_of!(eoe_param, subnet) - 12usize];
    ["Offset of field: eoe_param::default_gateway"]
        [::std::mem::offset_of!(eoe_param, default_gateway) - 16usize];
    ["Offset of field: eoe_param::dns_ip"][::std::mem::offset_of!(eoe_param, dns_ip) - 20usize];
    ["Offset of field: eoe_param::dns_name"][::std::mem::offset_of!(eoe_param, dns_name) - 24usize];
};
impl eoe_param {
    #[inline]
    pub fn mac_set(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mac_set(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mac_set_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_mac_set_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ip_set(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ip_set(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ip_set_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_ip_set_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn subnet_set(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_subnet_set(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn subnet_set_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_subnet_set_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn default_gateway_set(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_default_gateway_set(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn default_gateway_set_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_default_gateway_set_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dns_ip_set(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dns_ip_set(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dns_ip_set_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dns_ip_set_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dns_name_set(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dns_name_set(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dns_name_set_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dns_name_set_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mac_set: u8,
        ip_set: u8,
        subnet_set: u8,
        default_gateway_set: u8,
        dns_ip_set: u8,
        dns_name_set: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mac_set: u8 = unsafe { ::std::mem::transmute(mac_set) };
            mac_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ip_set: u8 = unsafe { ::std::mem::transmute(ip_set) };
            ip_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let subnet_set: u8 = unsafe { ::std::mem::transmute(subnet_set) };
            subnet_set as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let default_gateway_set: u8 = unsafe { ::std::mem::transmute(default_gateway_set) };
            default_gateway_set as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dns_ip_set: u8 = unsafe { ::std::mem::transmute(dns_ip_set) };
            dns_ip_set as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dns_name_set: u8 = unsafe { ::std::mem::transmute(dns_name_set) };
            dns_name_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " EoE IP request structure, storage only, no need to pack"]
pub type eoe_param_t = eoe_param;
#[doc = " EOE structure.\n Used to interpret EoE mailbox packets."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ec_EOEt {
    pub mbxheader: ec_mbxheadert,
    pub frameinfo1: u16,
    pub __bindgen_anon_1: ec_EOEt__bindgen_ty_1,
    pub data: [uint8; 1476usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ec_EOEt__bindgen_ty_1 {
    pub frameinfo2: u16,
    pub result: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_EOEt__bindgen_ty_1"][::std::mem::size_of::<ec_EOEt__bindgen_ty_1>() - 2usize];
    ["Alignment of ec_EOEt__bindgen_ty_1"]
        [::std::mem::align_of::<ec_EOEt__bindgen_ty_1>() - 2usize];
    ["Offset of field: ec_EOEt__bindgen_ty_1::frameinfo2"]
        [::std::mem::offset_of!(ec_EOEt__bindgen_ty_1, frameinfo2) - 0usize];
    ["Offset of field: ec_EOEt__bindgen_ty_1::result"]
        [::std::mem::offset_of!(ec_EOEt__bindgen_ty_1, result) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ec_EOEt"][::std::mem::size_of::<ec_EOEt>() - 1486usize];
    ["Alignment of ec_EOEt"][::std::mem::align_of::<ec_EOEt>() - 1usize];
    ["Offset of field: ec_EOEt::mbxheader"][::std::mem::offset_of!(ec_EOEt, mbxheader) - 0usize];
    ["Offset of field: ec_EOEt::frameinfo1"][::std::mem::offset_of!(ec_EOEt, frameinfo1) - 6usize];
    ["Offset of field: ec_EOEt::data"][::std::mem::offset_of!(ec_EOEt, data) - 10usize];
};
unsafe extern "C" {
    pub fn ecx_EOEdefinehook(
        context: *mut ecx_contextt,
        hook: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_EOEsetIp(
        context: *mut ecx_contextt,
        slave: uint16,
        port: uint8,
        ipparam: *mut eoe_param_t,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_EOEgetIp(
        context: *mut ecx_contextt,
        slave: uint16,
        port: uint8,
        ipparam: *mut eoe_param_t,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_EOEsend(
        context: *mut ecx_contextt,
        slave: uint16,
        port: uint8,
        psize: ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_EOErecv(
        context: *mut ecx_contextt,
        slave: uint16,
        port: uint8,
        psize: *mut ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_void,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_EOEreadfragment(
        MbxIn: *mut ec_mbxbuft,
        rxfragmentno: *mut uint8,
        rxframesize: *mut uint16,
        rxframeoffset: *mut uint16,
        rxframeno: *mut uint16,
        psize: *mut ::std::os::raw::c_int,
        p: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_config_init(usetable: uint8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_config_map(pIOmap: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_config_overlap_map(pIOmap: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_config_map_aligned(pIOmap: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_config_map_group(
        pIOmap: *mut ::std::os::raw::c_void,
        group: uint8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_config_overlap_map_group(
        pIOmap: *mut ::std::os::raw::c_void,
        group: uint8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_config_map_group_aligned(
        pIOmap: *mut ::std::os::raw::c_void,
        group: uint8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_config(usetable: uint8, pIOmap: *mut ::std::os::raw::c_void)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_config_overlap(
        usetable: uint8,
        pIOmap: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_recover_slave(slave: uint16, timeout: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_reconfig_slave(
        slave: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_config_init(context: *mut ecx_contextt, usetable: uint8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_config_map_group(
        context: *mut ecx_contextt,
        pIOmap: *mut ::std::os::raw::c_void,
        group: uint8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_config_overlap_map_group(
        context: *mut ecx_contextt,
        pIOmap: *mut ::std::os::raw::c_void,
        group: uint8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_config_map_group_aligned(
        context: *mut ecx_contextt,
        pIOmap: *mut ::std::os::raw::c_void,
        group: uint8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_recover_slave(
        context: *mut ecx_contextt,
        slave: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ecx_reconfig_slave(
        context: *mut ecx_contextt,
        slave: uint16,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ec_sdoerror2string(sdoerrorcode: uint32) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ec_ALstatuscode2string(ALstatuscode: uint16) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ec_soeerror2string(errorcode: uint16) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ec_mbxerror2string(errorcode: uint16) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecx_err2string(Ec: ec_errort) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecx_elist2string(context: *mut ecx_contextt) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ec_elist2string() -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
